#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2020  Canonical Ltd.
# Author: Bin Li <bin.li@canonical.com>
#         Shih-Yuan Lee (FourDollars) <sylee@canonical.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import argparse
import collections
import difflib
import jinja2
import json
import lazr
import lsb_release
import oem_scripts
import os
import re
import requests
import shutil
import sys

from copy import copy
from distro_info import UbuntuDistroInfo
from glob import glob
from logging import debug, info, warning, error, critical
from oem_scripts import (
    SUBSCRIBER_LIST,
    TAG_LIST,
    _get_items_from_git,
    _run_command,
    remove_prefix,
    yes_or_ask,
)
from oem_scripts.LaunchpadLogin import LaunchpadLogin
from oem_scripts.logging import setup_logging
from tempfile import TemporaryDirectory

parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="""
examples:
    mir-bug create sutton.newell ace \"ThinkPad X1 Carbon Gen 8\"
    mir-bug check PLATFORM_JSON
    mir-bug update PLATFORM_JSON
    mir-bug collect oem-meta-mir-bugs.json""",
)

parser.add_argument("-d", "--debug", help="print debug messages", action="store_true")
parser.add_argument(
    "-q", "--quiet", help="Don't print info messages", action="store_true"
)

subparsers = parser.add_subparsers(dest="subcommand")

create = subparsers.add_parser(
    "create",
    help="[-h] [-o=bugID|--output=bugID] oemCodename platformCodename deviceName",
)
create.add_argument("oemCodename", help="Such as somerville, stella, or sutton.simon")
create.add_argument("platformCodename", help="Name deined by PM, like ace.")
create.add_argument("deviceName", help="ThinkPad X1 Carbon Gen 8")
create.add_argument(
    "-s",
    "--series",
    help="Specify the Ubuntu series to create the bug.",
)
create.add_argument(
    "-o",
    "--output",
    help="Specify a file name to write the bug number.",
    type=argparse.FileType("w", encoding="UTF-8"),
)

update = subparsers.add_parser(
    "update",
    help="[-h] [--ready] [--skip] [--tz=UTC-8] [--yes] [--kernel-flavour oem|default] PLATFORM_JSON",
)
update.add_argument(
    "json",
    help="Specify the platform json file to read the information.",
    type=argparse.FileType("r", encoding="UTF-8"),
)
update.add_argument("--yes", help="Say yes for all prompts.", action="store_true")
update.add_argument(
    "--skip",
    help="Skip updating bootstrap branch of Git repository.",
    action="store_true",
)
update.add_argument(
    "--kernel-flavour",
    help="Set the kernel flavour in debian/control.",
    choices=["oem", "default"],
)
update.add_argument(
    "--tz", help="Specify the value for TZ. (UTC-8 by default)", default="UTC-8"
)
update.add_argument(
    "--ready",
    action="store_true",
    help="Update the bug to Fix Committed, also affects 'Ubuntu', and subscribe 'ubuntu-sponsors' and 'ubuntu-desktop'.",
)
update.add_argument(
    "--release", action="store_true", help="Update the bug for release."
)

check = subparsers.add_parser(
    "check",
    help="[-h] [--ready] [--release] [--skip] [--tz=UTC-8] [--kernel-flavour oem|default] PLATFORM_JSON",
)
check.add_argument(
    "json",
    help="Specify the platform json file to read the information.",
    type=argparse.FileType("r", encoding="UTF-8"),
)
check.add_argument(
    "--skip", help="Skip checking oem branch of Git repository.", action="store_true"
)
check.add_argument(
    "--kernel-flavour",
    help="Set the kernel flavour in debian/control.",
    choices=["oem", "default"],
)
check.add_argument(
    "--tz", help="Specify the value for TZ. (UTC-8 by default)", default="UTC-8"
)
check.add_argument(
    "--ready",
    action="store_true",
    help="Check if the bug is Fix Committed, also affects 'Ubuntu', and subscribe 'ubuntu-sponsors' and 'ubuntu-desktop'.",
)
check.add_argument(
    "--release", action="store_true", help="Check if the bug is ready to release."
)

collect = subparsers.add_parser("collect", help="[-h] [--ubuntu-certified] jsonFile")
collect.add_argument(
    "json",
    help="Specify the json file name to write.",
    type=argparse.FileType("w", encoding="UTF-8"),
)
collect.add_argument(
    "--ubuntu-certified",
    action="store_true",
    help="Only collect those bugs with the 'ubuntu-certified' tag.",
)
collect.add_argument(
    "--verification-needed",
    action="store_true",
    help="Only collect those bugs with the 'verification-needed' tag.",
)

args = parser.parse_args()

setup_logging(debug=args.debug, quiet=args.quiet)

pattern = re.compile(r".*\[MIR\]\W*oem-([^-]*)-(.*)-meta\W*")
pattern2 = re.compile(r".*\[MIR\]\[(.*)\]\W*oem-([^-]*)-(.*)-meta\W*")


def _grouping_market_names(market_names: list, maxsplit=1) -> str:
    # Remove empty item
    while "" in market_names:
        market_names.remove("")
    tmp = collections.defaultdict(list)
    space_in_model = False
    try:
        for market_name in sorted(market_names):
            if maxsplit == 1:
                name, model = market_name.split(maxsplit=maxsplit)
                tmp[name].append(model)
                if " " in model:
                    space_in_model = True
            elif maxsplit == 2:
                brand, name, model = market_name.split(maxsplit=maxsplit)
                tmp[brand + " " + name].append(model)
                if " " in model:
                    space_in_model = True
    except ValueError:
        return ", ".join(sorted(market_names))

    if space_in_model:
        return ", ".join(f"{name} {', '.join(models)}" for name, models in tmp.items())
    else:
        return ", ".join(f"{name} {'/'.join(models)}" for name, models in tmp.items())


def create_bug(lp, oemCodename, platformCodename, deviceName, series):
    info("Creating bug...")
    tempList = oemCodename.split(".")
    oemCodenameNogroup = tempList[0]
    if len(tempList) == 2:
        oemGroupName = tempList[1]
    else:
        oemGroupName = ""

    # metaPkgName's examples
    # oem-somerville-metapod-meta
    # oem-sutton.newell-ace-meta
    metaPkgName = "oem-" + oemCodename + "-" + platformCodename + "-meta"

    if oemGroupName.strip() != "":
        branchName = oemGroupName + "." + platformCodename + f"-{series}-ubuntu"
    else:
        branchName = platformCodename + f"-{series}-ubuntu"

    project = lp.projects["oem-priority"]

    if series == "focal":
        bt = f"[DRAFT][MIR] {metaPkgName}"
    else:
        bt = f"[DRAFT][MIR][{series}] {metaPkgName}"
    bd = "[DRAFT]" + read_from_template(
        metaPkgName=metaPkgName,
        branchName=branchName,
        oemCodenameNogroup=oemCodenameNogroup,
        deviceName=deviceName,
        series=series,
    )
    bug = lp.bugs.createBug(
        description=bd,
        target=project,
        title=bt,
        information_type="Public",
        tags=TAG_LIST,
    )

    info("meta package public bug: " + bug.web_link)

    if args.output:
        args.output.write(f"{bug.id}\n")

    for task in bug.bug_tasks:
        task.status = "Confirmed"
        task.importance = "Critical"
        # Assign to reporter by default
        task.assignee = lp.me
        task.lp_save()

    # Subscribe the oem-solutions-engineers
    bug.subscribe(person=lp.people["oem-solutions-engineers"])
    bug.lp_save()


def collect_bugs(lp, output):
    info("Collecting bugs...")
    project = lp.projects["oem-priority"]
    tasks = project.searchTasks(
        status=[
            "New",
            "Incomplete",
            "Triaged",
            "Opinion",
            "Confirmed",
            "In Progress",
            "Fix Committed",
        ],
        search_text="[MIR]",
    )
    try:
        total = int(tasks.total_size)
    except TypeError:  # When the total size becomes more than 50, it won't return 'int' but 'ScalarValue' instead.
        total = tasks.total_size.value

    bugs = []
    for counter, task in enumerate(tasks, 1):
        bug = task.bug

        if (
            "[MIR]" not in bug.title
            or "oem" not in bug.title
            or "meta" not in bug.title
        ):
            info(
                f"{counter}/{total} LP: #{bug.id} {bug.title} ({task.status}) **NOT MATCHED**"
            )
            continue

        if args.ubuntu_certified and "ubuntu-certified" not in bug.tags:
            info(
                f"{counter}/{total} LP: #{bug.id} {bug.title} ({task.status}) **NOT CERTIFIED**"
            )
            continue

        if args.verification_needed:
            verification_needed = False
            for tag in bug.tags:
                if tag.startswith("verification-needed"):
                    verification_needed = True
            if not verification_needed:
                info(
                    f"{counter}/{total} LP: #{bug.id} {bug.title} ({task.status}) **NOT VERIFICATION NEEDED**"
                )
                continue

        result = pattern2.match(bug.title)
        git = None
        if result:
            series = result.group(1)
            project = result.group(2)
            platform = result.group(3)
            git = f"git clone --depth 1 -b {platform}-{series}-ubuntu https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta oem-{project}-{platform}-meta"
        else:
            result = pattern.match(bug.title)
            if result:
                if "." in result.group(1):
                    project, group = result.group(1).split(".")
                else:
                    project = result.group(1)
                    group = None
                platform = result.group(2)
                if group:
                    git = f"git clone --depth 1 -b {group}.{platform}-focal-ubuntu https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta oem-{project}.{group}-{platform}-meta"
                else:
                    git = f"git clone --depth 1 -b {platform}-focal-ubuntu https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta oem-{project}-{platform}-meta"

        subscriptions = []
        for subscription in bug.subscriptions:
            subscriptions.append(subscription.person.name)

        ubuntu_status = None
        for bug_task in bug.bug_tasks:
            if bug_task.bug_target_name == "ubuntu":
                ubuntu_status = bug_task.status

        attachments = []
        for attachment in bug.attachments:
            attachments.append(
                {
                    "title": attachment.title,
                    "data_link": attachment.data_link,
                    "type": attachment.type,
                }
            )
        clip = {
            "bug": "https://bugs.launchpad.net/bugs/%s" % bug.id,
            "link": bug.self_link,
            "title": bug.title,
            "importance": task.importance,
            "tag": bug.tags,
            "description": bug.description,
            "status": task.status,
            "ubuntu_status": ubuntu_status,
            "owner": task.owner.name,
            "assignee": task.assignee.name if task.assignee else "none",
            "subscriptions": subscriptions,
            "attachments": attachments,
            "git": git,
        }
        bugs.append(clip)
        info(f"{counter}/{total} LP: #{bug.id} {bug.title} ({task.status})")

    info("total: %d matched" % len(bugs))
    output.write(json.dumps(bugs, sort_keys=True, separators=(",", ":")))
    output.write("\n")


def update_bug(
    lp,
    series: str,
    bug_number: int,
    yes: bool,
    certified: bool = False,
    certified_hardwares: list = [],
) -> None:
    bug = lp.bugs[bug_number]
    info(f'Updating LP: #{bug_number} - "{bug.title}" ...')
    desc, pkg_name = check_bug_description(bug, certified_hardwares, series=series)
    bug_modified = False
    task_modified = False

    if desc and yes_or_ask(yes, "Do you want to update the bug description?"):
        bug_modified = True
        bug.description = desc

    if check_bug_title(bug, pkg_name, series) is False and yes_or_ask(
        yes, "Do you want to update the bug title?"
    ):
        bug_modified = True
        if series == "focal":
            bug.title = f"[MIR] {pkg_name}"
        else:
            bug.title = f"[MIR][{series}] {pkg_name}"

    if bug_modified:
        bug.lp_save()
        bug_modified = False

    if check_bug_importance(bug) is False:
        for task in bug.bug_tasks:
            if task.importance != "Critical":
                if task.bug_target_name == "oem-priority" and yes_or_ask(
                    yes,
                    f"Do you want to update the importance of {task.bug_target_name} from {task.importance} to Critical?",
                ):
                    task_modified = True
                    task.importance = "Critical"
                    task.lp_save()

    update_bug_status(bug, pkg_name, yes, series)

    check_and_update_bug_subscriptions(lp, bug, update=True, yes=yes)

    if check_bug_tags(bug, certified) is False:
        tags = copy(bug.tags)
        if certified:
            if args.release:
                taglist = TAG_LIST + ["ubuntu-certified", "oem-done-upload"]
            elif args.ready:
                taglist = TAG_LIST + ["ubuntu-certified", "oem-needs-upload"]
            else:
                taglist = TAG_LIST + ["ubuntu-certified"]
        else:
            taglist = TAG_LIST
        for tag in taglist:
            if tag not in bug.tags and yes_or_ask(
                yes, f"Do you want to add '{tag}' tag?"
            ):
                bug_modified = True
                tags.append(tag)
        for tag in bug.tags:
            if tag.startswith("oem-scripts-"):
                if tag[len("oem-scripts-") :] != oem_scripts.__version__:
                    if yes_or_ask(yes, f"Do you want to remove '{tag}' tag?"):
                        tags.remove(tag)
            elif certified and args.release and tag == "oem-needs-upload":
                if yes_or_ask(yes, f"Do you want to remove '{tag}' tag?"):
                    tags.remove(tag)
        if tags != bug.tags:
            bug.tags = tags

    check_and_update_git_repo(
        bug, pkg_name, series=series, yes=yes, update=True, username=lp.me.name
    )

    check_and_update_bug_attachments(bug, pkg_name, series=series, update=True, yes=yes)

    if bug_modified:
        bug.lp_save()
        info(f"LP: #{bug_number} is updated.")
    elif task_modified:
        info(f"LP: #{bug_number} is updated.")
    elif yes:
        info("Everything looks OK.")


def check_bug(
    lp,
    bug_number: int,
    series: str,
    certified: bool = False,
    certified_hardwares: list = [],
) -> None:
    bug = lp.bugs[bug_number]
    info(f'Checking LP: #{bug_number} - "{bug.title}" ...')
    need_fixing = False
    desc, pkg_name = check_bug_description(bug, certified_hardwares, series=series)
    if desc:
        need_fixing = True
    if check_bug_title(bug, pkg_name, series) is False:
        need_fixing = True
    if check_bug_importance(bug) is False:
        need_fixing = True
    if check_bug_status(bug, pkg_name, series) is False:
        need_fixing = True
    if check_and_update_bug_subscriptions(lp, bug) is False:
        need_fixing = True
    if check_bug_tags(bug, certified) is False:
        need_fixing = True
    if check_and_update_git_repo(bug, pkg_name, series=series) is False:
        need_fixing = True
    if check_and_update_bug_attachments(bug, pkg_name, series=series) is False:
        need_fixing = True
    if (
        not args.skip
        and check_and_update_git_repo(bug, pkg_name, series=series, bootstrap=False)
        is False
    ):
        need_fixing = True

    if need_fixing is False:
        info("Everything looks OK.")
    else:
        exit(1)


def check_bug_description(bug, certified_hardwares: list, series: str) -> (str, str):
    info("Checking bug description...")
    if series == "focal":
        result = pattern.match(bug.title)
        if not result:
            critical(f"LP: #{bug.id} '{bug.title}' is NOT MATCHED")
            exit(1)
        if "." in result.group(1):
            project, group = result.group(1).split(".")
            platform = result.group(2)
            branchName = group + "." + platform + "-focal-ubuntu"
        else:
            project = result.group(1)
            platform = result.group(2)
            group = None
            branchName = platform + "-focal-ubuntu"
        metaPkgName = f"oem-{result.group(1)}-{result.group(2)}-meta"
        series = "focal"
    else:
        result = pattern2.match(bug.title)
        series = result.group(1)
        project = result.group(2)
        platform = result.group(3)
        group = None
        branchName = platform + f"-{series}-ubuntu"
        metaPkgName = f"oem-{project}-{platform}-meta"

    prog = re.compile(r"\W*We want to improve the hardware support for ([^.]*).\W*")
    deviceName = None

    for line in bug.description.split("\n"):
        result = prog.match(line)
        if not result:
            continue
        deviceName = result.group(1)
        if deviceName.endswith(f" on {series}"):
            deviceName = deviceName[:-9]
        break
    else:
        critical(f"LP: #{bug.id} '{bug.title}' can not find the device name.")
        exit(1)

    desc = read_from_template(
        metaPkgName=metaPkgName,
        branchName=branchName,
        oemCodenameNogroup=project,
        deviceName=deviceName,
        series=series,
    )

    if certified_hardwares:
        desc += "\n"

    for hardware in certified_hardwares:
        response = requests.get(f"https://ubuntu.com/certified/{hardware}")
        if response.status_code != 200:
            continue
        desc += f"\nhttps://ubuntu.com/certified/{hardware}"

    if bug.description != desc:
        d = difflib.Differ()
        diff = d.compare(bug.description.split("\n"), desc.split("\n"))
        error("The description needs to update.")
        if not args.quiet:
            for i, line in enumerate(diff):
                if i == 0:
                    info(line)
                else:
                    print(line)
        return (desc, metaPkgName)
    return (None, metaPkgName)


def check_bug_title(bug, pkg_name: str, series: str) -> bool:
    info("Checking bug title...")
    if series == "focal" and bug.title == f"[MIR] {pkg_name}":
        return True
    elif bug.title == f"[MIR][{series}] {pkg_name}":
        return True
    if series == "focal":
        error(f"The bug title shall be '[MIR] {pkg_name}' but it is '{bug.title}'.")
    else:
        error(
            f"The bug title shall be '[MIR][{series}] {pkg_name}' but it is '{bug.title}'."
        )
    return False


def check_bug_importance(bug) -> bool:
    info("Checking bug importance...")
    result = True
    for task in bug.bug_tasks:
        if task.bug_target_name == "oem-priority" and task.importance != "Critical":
            error(
                f"The '{task.bug_target_name}' importance is expected to be 'Critical' instead of '{task.importance}'."
            )
            result = False
    return result


def _expected_status(target_name: str, status: str, expected: str) -> bool:
    if status != expected:
        error(
            f"The '{target_name}' status is expected to be '{expected}' instead of '{status}'."
        )
        return False
    return True


def check_bug_status(bug, pkg_name: str, series: str) -> bool:
    info("Checking bug status...")
    result = True
    saw_ubuntu_task = False
    for task in bug.bug_tasks:
        if task.bug_target_name == "oem-priority":
            if args.ready:
                if (
                    _expected_status(task.bug_target_name, task.status, "Fix Committed")
                    is False
                ):
                    result = False
            else:
                if (
                    _expected_status(task.bug_target_name, task.status, "In Progress")
                    is False
                ):
                    result = False
        elif (
            task.bug_target_name == "ubuntu"
            or f"{pkg_name} (Ubuntu)" in task.bug_target_name
            or f"{pkg_name} (Ubuntu {series.capitalize()})" in task.bug_target_name
        ):
            saw_ubuntu_task = True
            if args.release:
                if (
                    _expected_status(task.bug_target_name, task.status, "In Progress")
                    is False
                ):
                    result = False
            elif args.ready:
                if (
                    _expected_status(task.bug_target_name, task.status, "Confirmed")
                    is False
                ):
                    result = False
            else:
                if (
                    _expected_status(task.bug_target_name, task.status, "Incomplete")
                    is False
                ):
                    result = False
        else:
            critical(f"It is unexpected to have '{task.bug_target_name}' task")
    if args.ready and saw_ubuntu_task is False:
        result = False
        error("There is no 'ubuntu' status.")
    return result


def _ok_to_change_status(
    target_name: str, orig_status: str, new_status: str, yes: bool
) -> bool:
    if orig_status == new_status:
        return False
    if yes_or_ask(
        yes,
        f"Would you like to change the '{target_name}' status from '{orig_status}' to '{new_status}'?",
    ):
        return True
    return False


def _change_task_status(task, new_status: str, yes: bool) -> bool:
    if _expected_status(
        task.bug_target_name, task.status, new_status
    ) is False and _ok_to_change_status(
        task.bug_target_name, task.status, new_status, yes
    ):
        task.status = new_status
        task.lp_save()


def update_bug_status(bug, pkg_name: str, yes: bool, series: str) -> None:
    info("Updating bug status...")
    saw_ubuntu_task = False
    for bug_task in bug.bug_tasks:
        if bug_task.bug_target_name == "oem-priority":
            if args.ready:
                _change_task_status(bug_task, "Fix Committed", yes)
            else:
                _change_task_status(bug_task, "In Progress", yes)
        elif (
            bug_task.bug_target_name == "ubuntu"
            or f"{pkg_name} (Ubuntu)" in bug_task.bug_target_name
            or f"{pkg_name} (Ubuntu {series.capitalize()})" in bug_task.bug_target_name
        ):
            saw_ubuntu_task = True
            if args.release:
                _change_task_status(bug_task, "In Progress", yes)
            elif args.ready:
                _change_task_status(bug_task, "Confirmed", yes)
            elif yes_or_ask(
                yes,
                f"Would you like to delete the '{bug_task.bug_target_name}' bug_task? (Don't affect '{bug_task.bug_target_display_name}')",
            ):
                try:
                    bug_task.lp_delete()
                except lazr.restfulclient.errors.BadRequest as e:
                    warning(
                        f"{bug_task.bug_target_name} can not be deleted, so changing the status to Incomplete instead."
                    )
                    debug(e)
                    _change_task_status(bug_task, "Incomplete", yes)
                except lazr.restfulclient.errors.Unauthorized as e:
                    warning(
                        f"{bug_task.bug_target_name} can not be deleted, so changing the status to Incomplete instead."
                    )
                    debug(e)
                    _change_task_status(bug_task, "Incomplete", yes)
            else:
                _change_task_status(bug_task, "Incomplete", yes)
        else:
            warning(f"{bug_task.bug_target_name} {bug_task.status}")
    if args.ready and saw_ubuntu_task is False:
        bug.addTask(target=lp.projects["Ubuntu"])
        for bug_task in bug.bug_tasks:
            if bug_task.bug_target_name == "ubuntu":
                _change_task_status(bug_task, "Confirmed", yes)


def check_and_update_bug_subscriptions(lp, bug, update=False, yes=False) -> bool:
    if update:
        info("Checking and updating subscriptions...")
    else:
        info("Checking subscriptions...")
    result = True
    subscriptions = []
    for subscription in bug.subscriptions:
        subscriptions.append(subscription.person.name)
        if not args.ready or not args.release:
            for subscriber in ("ubuntu-sponsors", "ubuntu-desktop"):
                if subscriber == subscription.person.name:
                    if subscription.canBeUnsubscribedByUser():
                        error(f"'{subscriber}' should not be in the subscriptions.")
                        if update and yes_or_ask(
                            yes, f"Do you want to unsubscribe '{subscriber}'?"
                        ):
                            bug.unsubscribe(person=lp.people[subscriber])
                        else:
                            result = False
                    else:
                        warning(
                            f"'{subscriber}' should not be in the subscriptions, and {lp.me.name} doesn't have the permission to unsubscribe it."
                        )
    if args.ready and args.release:
        for subscriber in SUBSCRIBER_LIST:
            if subscriber not in subscriptions:
                error(f"'{subscriber}' is not in the subscriptions.")
                if update and yes_or_ask(
                    yes, f"Do you want to subscribe '{subscriber}'?"
                ):
                    bug.subscribe(person=lp.people[subscriber])
                else:
                    result = False
    else:
        if "oem-solutions-engineers" not in subscriptions:
            error("'oem-solutions-engineers' is not in the subscriptions.")
            if update and yes_or_ask(
                yes, "Do you want to subscribe 'oem-solutions-engineers'?"
            ):
                bug.subscribe(person=lp.people[subscriber])
            else:
                result = False
    return result


def check_bug_tags(bug, certified: bool = False) -> bool:
    info("Checking bug tags...")
    result = True
    if certified:
        if args.release:
            taglist = TAG_LIST + ["ubuntu-certified", "oem-done-upload"]
        elif args.ready:
            taglist = TAG_LIST + ["ubuntu-certified", "oem-needs-upload"]
        else:
            taglist = TAG_LIST + ["ubuntu-certified"]
    else:
        taglist = TAG_LIST
    for tag in taglist:
        if tag not in bug.tags:
            error(f"'{tag}' is not in the tags.")
            result = False
    return result


def check_and_update_bug_attachments(
    bug,
    pkg_name: str,
    series: str,
    update=False,
    yes=False,
) -> bool:
    if update:
        info("Checking and updating attachments...")
    else:
        info("Checking attachments...")

    if series != "focal":
        result = pattern2.match(f"[MIR][{series}] {pkg_name}")
        if result is None:
            critical(f"{pkg_name} failed.")
            exit(1)
        project = result.group(2)
        platform = result.group(3)
        branch = f"{platform}-{series}-ubuntu"
    else:
        result = pattern.match(f"[MIR] {pkg_name}")

        if result is None:
            critical(f"{pkg_name} failed.")
            exit(1)

        if "." in result.group(1):
            project, group = result.group(1).split(".")
        else:
            project = result.group(1)
            group = None
        platform = result.group(2)

        if group:
            branch = f"{group}.{platform}-focal-ubuntu"
        else:
            branch = f"{platform}-focal-ubuntu"

    git_command = (
        "git",
        "clone",
        "--depth",
        "1",
        "-b",
        branch,
        f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta",
        pkg_name,
    )

    debdiff = None
    content = None
    found = False  # some debdiff is found

    with TemporaryDirectory() as tmpdir:
        os.chdir(tmpdir)
        _run_command(
            [
                "wget",
                "https://git.launchpad.net/ubuntu-archive-tools/plain/oem-metapackage-mir-check",
            ]
        )
        _run_command(git_command)
        git_dir = os.path.join(tmpdir, pkg_name)
        os.chdir(git_dir)
        if args.release:
            # Change debian/changelog back to UNRELEASED
            lines = None
            changelog = os.path.join(tmpdir, pkg_name, "debian", "changelog")
            with open(changelog, "r") as f:
                lines = f.readlines()

            version = UbuntuDistroInfo().version(series).split(" ")[0]
            lines[0] = f"{pkg_name} ({version}~ubuntu1) UNRELEASED; urgency=medium\n"
            with open(changelog, "w") as f:
                f.writelines(lines)
        _run_command(["dpkg-buildpackage", "-S", "-us", "-uc"])
        os.chdir(tmpdir)
        dsc = glob(f"{pkg_name}*.dsc")[0]
        prog = re.compile(fr"{pkg_name}_(.*).dsc")
        result = prog.match(dsc)
        debian_version = result.group(1)
        debdiff = f"{pkg_name}_{debian_version}.debdiff"
        # It should generate some debdiff so the return code should be 1 unless comparing to oem-qemu-meta itself.
        debug(f"TZ={args.tz}")
        content, _, _ = _run_command(
            ["bash", "oem-metapackage-mir-check", dsc],
            returncode=(1,),
            env=dict(os.environ, TZ=args.tz),
        )
        content += "\n"
        with open(debdiff, "w") as f:
            diff_started = False
            for line in content.split("\n"):
                if diff_started is False and line.startswith("diff -Nru oem-qemu-meta"):
                    diff_started = True
                if diff_started:
                    f.write(line + "\n")
        with open(debdiff, "r") as f:
            content = f.read()

        for attachment in bug.attachments:
            if "debdiff" in attachment.title:
                _run_command(["wget", attachment.data_link, "-O", "data"])
                if sys.stdout.isatty():
                    out, err, returncode = _run_command(
                        ["colordiff", "-ur", "data", debdiff], returncode=(0, 1)
                    )
                else:
                    out, err, returncode = _run_command(
                        ["diff", "-ur", "data", debdiff], returncode=(0, 1)
                    )
                if returncode == 1:
                    warning(
                        f"{attachment.title} - {attachment.web_link} has unexpected content."
                    )
                    info(f"{out}")
                    found = True
                    if update and yes_or_ask(
                        yes,
                        f"Do you want to remove {attachment.title} - {attachment.web_link}?",
                    ):
                        try:
                            attachment.removeFromBug()
                        except lazr.restfulclient.errors.NotFound as e:
                            debug(e)
                elif returncode == 0:
                    info(f"{attachment.title} - {attachment.data_link} looks OK.")
                    return True

    if found:
        error(f"{debdiff} needs to update.")
    else:
        error(f"There is no {debdiff}.")
    info(content)
    if update and yes_or_ask(yes, f"Do you want to attach {debdiff}?"):
        bug.addAttachment(
            filename=debdiff,
            data=content.encode("utf-8"),
            comment=f"Attach {debdiff} by oem-scripts {oem_scripts.__version__}.",
            is_patch=True,
        )
        return True
    else:
        return False


def check_and_update_git_repo(
    bug,
    pkg_name: str,
    series: str,
    yes=False,
    bootstrap=True,
    update=False,
    username=None,
) -> bool:
    if update:
        if bootstrap:
            info("Checking and updating git repo for bootstrap branch...")
        else:
            info("Checking and updating git repo for oem branch...")
    else:
        if bootstrap:
            info("Checking git repo for bootstrap branch...")
        else:
            info("Checking git repo for oem branch...")

    if series != "focal":
        result = pattern2.match(f"[MIR][{series}] {pkg_name}")
        project = result.group(2)
        platform = result.group(3)
        group = None
        if bootstrap:
            suffix = "ubuntu"
        else:
            suffix = "oem"
        branch = f"{platform}-{series}-{suffix}"
    else:
        result = pattern.match(f"[MIR] {pkg_name}")

        if result is None:
            critical(f"{pkg_name} failed.")
            exit(1)

        if "." in result.group(1):
            project, group = result.group(1).split(".")
        else:
            project = result.group(1)
            group = None
        platform = result.group(2)

        if bootstrap:
            suffix = "ubuntu"
        else:
            suffix = "oem"

        if group:
            branch = f"{group}.{platform}-focal-{suffix}"
        else:
            branch = f"{platform}-focal-{suffix}"

    kernel_flavour, kernel_meta, market_name, ids = _get_items_from_git(
        project, branch, pkg_name
    )

    product_names = []

    if args.json:
        private_meta_bug = args.json.get("metabug", "")
        product_names = args.json.get("productnames", [])
        if group == "cmit":
            new_market_name = _grouping_market_names(
                args.json["productnames"], maxsplit=2
            )
            new_market_name = remove_prefix(new_market_name, "HP ")
        else:
            new_market_name = _grouping_market_names(args.json["productnames"])

        # The new_market_name will be replaced by short_description if it's provided in json
        # https://warthogs.atlassian.net/browse/CED-40
        # The first line of the "Description:" must be less than 80 characters long.
        # https://salsa.debian.org/lintian/lintian/-/blob/master/tags/s/synopsis-too-long.tag
        # In pkg-oem-meta, the Codename will be "Dell", "HP" and "Lenovo"
        # Description: hardware support for {Codename} {platformStr}
        #             |-------- 22 --------||--- 7 ---||--- 51 ----|
        # Description: hardware support for {Codename} {platformStr} (factory)
        #             |-------- 22 --------||--- 7 ---||--- 41 ----||-- 10 --|
        short_desc = args.json.get("short_description", "")
        len_short_desc = len(short_desc)
        if len_short_desc > 0:
            if len_short_desc < 41:
                new_market_name = short_desc
            else:
                warning(
                    f"The market name({short_desc}) in short description is {len_short_desc} bytes, it's more than 40 bytes!!!"
                )

        if market_name is None:
            market_name = new_market_name
        if market_name != new_market_name:
            if args.skip or not update:
                warning(
                    f"You may need to use '{new_market_name}' instead of '{market_name}'?"
                )
            elif yes_or_ask(
                yes,
                f"Do you want to use '{new_market_name}' instead of '{market_name}'?",
            ):
                market_name = new_market_name

    version = UbuntuDistroInfo().version(series).split(" ")[0]
    if kernel_flavour == "default":
        if kernel_meta is None:
            kernel_meta = f"linux-generic-hwe-{version}"
        elif kernel_meta == f"linux-generic-hwe-{version}":
            pass
        else:
            critical(
                f"{pkg_name}'s {branch} branch has unexpected kernel_flavour={kernel_flavour}, kernel_meta={kernel_meta}."
            )
            exit(1)
    elif kernel_flavour == "oem":
        if kernel_meta is None:
            kernel_meta = f"linux-oem-{version}"
        elif kernel_meta.startswith(f"linux-oem-{version}"):
            pass
        else:
            critical(
                f"{pkg_name}'s {branch} branch has unexpected kernel_flavour={kernel_flavour}, kernel_meta={kernel_meta}."
            )
            exit(1)

    if ids == []:
        error("Something wrong in debian/modaliases. Please fix it manually first.")
        return False

    def base_command(project):
        entry = f"pkg-{project}-meta"
        source_root = os.path.abspath(os.path.dirname(__file__))
        local_entry = os.path.join(source_root, entry)
        if os.path.exists(local_entry):
            # if calling ./mir-bug from source
            entry = local_entry
        command = [
            entry,
            "-s",
            series,
            "-k",
            kernel_meta,
            "-p",
            platform,
            "--public-bug",
            str(bug.id),
            "--private-bug",
            str(private_meta_bug),
        ]
        if market_name:
            command.extend(["--market-name", market_name])
            for product_name in product_names:
                command.extend(["--product-name", product_name])
        return command

    with TemporaryDirectory() as tmpdir:
        os.chdir(tmpdir)
        command = base_command(project)
        # Generated the meta package by pkg-oem-meta
        if project == "somerville":
            command.extend(ids)
        elif project == "stella":
            if group:
                command.extend(["-g", group])
            command.extend(ids)
        elif project == "sutton":
            if group:
                command.extend(["-g", group])
            for bvn, bvr, pvr in ids:
                if pvr:
                    command.append(f"bvn{bvn}:bvr{bvr}:pvr{pvr}")
                else:
                    command.append(f"bvn{bvn}:bvr{bvr}")
        _run_command(command)
        new_dir = os.path.join(tmpdir, pkg_name)
        os.chdir(new_dir)
        if bootstrap:
            _run_command(["git", "checkout", branch])

        os.chdir(tmpdir)
        os.rename(new_dir, new_dir + ".new")
        new_dir += ".new"
        shutil.rmtree(os.path.join(new_dir, ".git"))
        os.remove(os.path.join(new_dir, "debian", "changelog"))

        if username:
            git_repo = f"git+ssh://{username}@git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta"
        else:
            git_repo = f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta"
        git_command = ("git", "clone", "--depth", "1", "-b", branch, git_repo, pkg_name)
        _run_command(git_command)
        os.chdir(os.path.join(tmpdir, pkg_name))
        shutil.copytree(new_dir, ".", dirs_exist_ok=True)

        if bootstrap:
            # Update debian/changelog
            lines = None
            changelog = os.path.join(tmpdir, pkg_name, "debian", "changelog")
            with open(changelog, "r") as f:
                lines = f.readlines()

            version = UbuntuDistroInfo().version(series).split(" ")[0]
            if args.release:
                lines[0] = f"{pkg_name} ({version}~ubuntu1) {series}; urgency=medium\n"
            else:
                lines[
                    0
                ] = f"{pkg_name} ({version}~ubuntu1) UNRELEASED; urgency=medium\n"

            if f"(LP: #{bug.id})" not in lines[2] and lines[2].startswith(
                "  * Meta package for"
            ):
                lines[2] = "  " + lines[2].strip() + f" (LP: #{bug.id})\n"

            with open(changelog, "w") as f:
                f.writelines(lines)
            # Update XB-Ubuntu-OEM-Kernel-Flavour in debian/control
            if args.kernel_flavour:
                lines = None
                control = os.path.join(tmpdir, pkg_name, "debian", "control")
                with open(control, "r") as f:
                    lines = f.readlines()
                for i, line in enumerate(lines):
                    if line.startswith("XB-Ubuntu-OEM-Kernel-Flavour:"):
                        lines[
                            i
                        ] = f"XB-Ubuntu-OEM-Kernel-Flavour: {args.kernel_flavour}\n"
                        break
                with open(control, "w") as f:
                    f.writelines(lines)
        # Remove deprecated autopkgtest file
        deprecated_test = os.path.join(tmpdir, pkg_name, "debian", "tests", pkg_name)
        if os.path.exists(deprecated_test):
            _run_command(["git", "rm", f"debian/tests/{pkg_name}"])

        # Remove deprecated debian/compat
        deprecated_compat = os.path.join(tmpdir, pkg_name, "debian", "compat")
        if os.path.exists(deprecated_compat):
            _run_command(["git", "rm", "debian/compat"])

        # Check git status
        if args.debug:
            debug("$ git status")
            out, _, _ = _run_command(["git", "status"])
            print(out)

        _run_command(["git", "add", "."])
        out, _, _ = _run_command(["git", "diff", "--color=always", "--cached"])
        if out != b"":
            warning("$ git diff")
            print(out)
            if update is True:
                if args.skip:
                    warning(
                        f"The update of the '{branch}' branch of {pkg_name}'s Git repository is skipped on demand."
                    )
                    return False
                elif yes_or_ask(
                    yes,
                    f"Do you want to commit and push the changes above into the '{branch}' branch of {pkg_name}'s Git repository?",
                ):
                    _run_command(
                        [
                            "git",
                            "commit",
                            "-a",
                            "-m",
                            f"Updated by oem-scripts {oem_scripts.__version__}.",
                        ]
                    )
                    _run_command(["git", "push"])
                    return True
            else:
                if bootstrap:
                    error(
                        f"The '{branch}' branch of {pkg_name} in Git repository needs to update."
                    )
                else:
                    warning(
                        f"The '{branch}' branch of {pkg_name} in Git repository may need to update."
                    )
                return False
        else:
            info(f"The '{branch}' branch of {pkg_name} in Git repository looks fine.")
            return True


def read_from_template(metaPkgName, branchName, oemCodenameNogroup, deviceName, series):
    version = UbuntuDistroInfo().version(series).split(" ")[0]
    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(["./", "/usr/share/oem-scripts"])
    )
    template = env.get_template("oem-meta-package.mir.jinja2")
    return template.render(
        metaPkgName=metaPkgName,
        branchName=branchName,
        oemCodenameNogroup=oemCodenameNogroup,
        deviceName=deviceName,
        version=version,
        series=series,
    )


def handle_bug(lp, args, handler, overwrite_args=None):
    args.json = json.load(args.json)
    certified = False
    if (
        args.ready
        and args.json
        and type(args.json) is dict
        and len(args.json.get("certify-planning", [])) != 0
    ):
        certified = True
        for bug_id in args.json["certify-planning"]:
            bug = lp.bugs[bug_id]
            for task in bug.bug_tasks:
                if task.bug_target_name == "certify-planning":
                    if task.status != "Fix Released":
                        certified = False

    certified_hardwares = args.json["certification-hardware"] if certified else []
    bug_number = args.json["mirbug"]

    if type(bug_number) == str:
        bug_number = int(bug_number)
    elif type(bug_number) == int:
        pass
    else:
        unexpected = type(bug_number)
        raise Exception(f"Unexpected '{unexpected}' type")

    kwargs = (overwrite_args or (lambda x: x))(
        {
            "series": args.json["series"],
            "bug_number": bug_number,
            "certified": certified,
            "certified_hardwares": certified_hardwares,
        }
    )

    handler(lp, **kwargs)


if args.subcommand:
    login = LaunchpadLogin()
    lp = login.lp

if args.subcommand == "create":
    if not args.series:
        series = lsb_release.get_os_release()["CODENAME"]
    else:
        series = args.series
    if not UbuntuDistroInfo().is_lts(series):
        series = UbuntuDistroInfo().lts()
    create_bug(lp, args.oemCodename, args.platformCodename, args.deviceName, series)
elif args.subcommand == "update":

    def append_yes(kwargs):
        kwargs["yes"] = args.yes
        return kwargs

    handle_bug(lp, args, update_bug, append_yes)
elif args.subcommand == "check":
    handle_bug(lp, args, check_bug)
elif args.subcommand == "collect":
    collect_bugs(lp, args.json)
else:
    parser.print_help()
