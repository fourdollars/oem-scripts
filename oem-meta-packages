#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2020  Canonical Ltd.
# Author: Shih-Yuan Lee (FourDollars) <sylee@canonical.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import argparse
import difflib
import lazr
import os
import types

from apt import apt_pkg
from logging import info, warning, error, debug  # , critical
from oem_scripts.LaunchpadLogin import LaunchpadLogin
from oem_scripts.logging import setup_logging

parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                 epilog="""
Make all bugs of all oem meta packages be subscribed by oem-solutions-engineers.
 (search current apt source for package lists)

Check "To all bugs in oem-qemu-meta in Ubuntu:" on https://launchpad.net/ubuntu/+source/oem-qemu-meta/+subscribe for example.

examples:
    oem-meta-packages subscribe""")

parser.add_argument("-d", "--debug",
                    help="print debug messages", action="store_true")
parser.add_argument("-q", "--quiet",
                    help="Don't print info messages", action="store_true")
parser.add_argument("-v", "--verbose", action="store_true",
                    help="print verbose messages")
parser.add_argument("--apt-dir",
                    type=str,
                    help="specify the dir for apt")

subparsers = parser.add_subparsers(dest="subcommand")

subscribe = subparsers.add_parser('subscribe', help='[-h] [--yes]')
subscribe.add_argument("--yes",
                       help="Say yes for all prompts.", action="store_true")

unsubscribe = subparsers.add_parser('unsubscribe', help='[-h] [--yes] pkgName')
unsubscribe.add_argument("pkgName", type=str,
                         help="Specify the package name to unsubscribe.")
unsubscribe.add_argument("--yes",
                         help="Say yes for all prompts.", action="store_true")

args = parser.parse_args()

setup_logging(debug=args.debug, quiet=args.quiet)

if args.subcommand:
    login = LaunchpadLogin()
    lp = login.lp

if args.apt_dir:
    apt_pkg.init_config()
    if args.debug:
        old = apt_pkg.config.dump()
    apt_pkg.config.set("Dir", args.apt_dir)
    apt_pkg.config.set("Dir::State::status", os.path.join(args.apt_dir, "var/lib/dpkg/status"))
    if args.debug:
        new = apt_pkg.config.dump()
        d = difflib.Differ()
        diff = d.compare(old.split('\n'), new.split('\n'))
        for line in diff:
            debug(line.strip())
    apt_pkg.init_system()


def yes_or_ask(yes: bool, message: str) -> bool:
    if yes:
        print(f"> \033[1;34m{message}\033[1;0m (y/n) y")
        return True
    while True:
        res = input(f"> \033[1;34m{message}\033[1;0m (y/n) ").lower()
        if res not in {"y", "n"}:
            continue
        if res == 'y':
            return True
        else:
            return False


def _debug_obj(pkg) -> None:

    if not args.debug:
        return

    debug(dir(pkg))

    for attr in dir(pkg):
        if not attr.startswith('__'):
            if not isinstance(pkg.__getattribute__(attr), types.BuiltinFunctionType):
                debug(f"{attr}: {pkg.__getattribute__(attr)}")


cache = apt_pkg.Cache(progress=None)

if args.subcommand == 'subscribe':
    for pkg in cache.packages:
        name = pkg.name
        if not name.startswith('oem-') or not name.endswith('-meta'):
            continue
        info(f"Checking the subscriptions for {name}...")
        source = lp.distributions['ubuntu'].getSourcePackage(name=name)
        if 'oem-solutions-engineers' in map(lambda x: x.subscriber.name, source.getSubscriptions()):
            info(f"ubuntu/{name} has subscribed oem-solutions-engineers.")
            continue
        warning(f"ubuntu/{name} didn't subscribe oem-solutions-engineers yet.")
        if yes_or_ask(args.yes, f"Would you like to subscribe 'oem-solutions-engineers' for ubuntu/{name}?"):
            try:
                # When a person is subscribed to a source package, one actually subscribe all bugs for it.
                source.addBugSubscription(subscriber=lp.people['oem-solutions-engineers'])
            except lazr.restfulclient.errors.Unauthorized as e:
                error(f"{lp.me.name} does not have permission to subscribe oem-solutions-engineers.")
                if args.verbose:
                    print(e)
                exit(1)
elif args.subcommand == 'unsubscribe':
    source = lp.distributions['ubuntu'].getSourcePackage(name=args.pkgName)
    subscriptions = source.getSubscriptions()
    for subscription in subscriptions:
        if subscription.subscriber.name == 'oem-solutions-engineers':
            info(f"ubuntu/{args.pkgName} has subscribed oem-solutions-engineers.")
            if yes_or_ask(args.yes, f"Would you like to unsubscribe 'oem-solutions-engineers' for ubuntu/{args.pkgName}?"):
                try:
                    source.removeBugSubscription(subscriber=lp.people['oem-solutions-engineers'])
                except lazr.restfulclient.errors.Unauthorized as e:
                    error(f"{lp.me.name} does not have permission to unsubscribe oem-solutions-engineers.")
                    if args.verbose:
                        print(e)
                    exit(1)
            exit(0)
else:
    parser.print_help()
