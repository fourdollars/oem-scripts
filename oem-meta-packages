#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2020  Canonical Ltd.
# Author: Shih-Yuan Lee (FourDollars) <sylee@canonical.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import argparse
import collections
import difflib
import json
import lazr
import lsb_release
import oem_scripts
import os
import re
import requests
import types

from abc import ABCMeta, abstractmethod
from apt import apt_pkg
from configparser import ConfigParser
from distro_info import UbuntuDistroInfo
from logging import debug, info, warning, error, critical
from oem_scripts import ALLOWED_KERNEL_META_LIST, _run_command
from oem_scripts.LaunchpadLogin import LaunchpadLogin
from oem_scripts.logging import setup_logging
from pydantic import BaseModel
from string import Template
from tempfile import TemporaryDirectory

SUBSCRIBER = "canonical-mainstream"

staging_copy_template = Template(
    '''Operation: copy_package
Source: $source
Destination: $destination
Package: $packages
Production: $production
===== Description =====

OEM metapackage.

Please verify the staging archive,
"""
deb https://$username:<password>@cesg.canonical.com/canonical $destination public
deb-src https://$username:<password>@cesg.canonical.com/canonical $destination public
"""
You can find <password> on $url.

And then verify the production archive.
"""
deb http://oem.archive.canonical.com $distribution $component
deb-src http://oem.archive.canonical.com $distribution $component
"""'''
)


class CustomEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, BaseModel):
            return obj.dict()
        return super().default(obj)


class PkgData(BaseModel):
    version: str
    archive: str
    kernel_flavour: str
    kernel_meta: str
    fingerprint: str
    market_name: str


class BootstrapGroup(BaseModel):
    git: PkgData
    ppa: PkgData
    proposed: PkgData
    ubuntu: PkgData


class OemGroup(BaseModel):
    git: PkgData
    ppa: PkgData
    devel: PkgData
    staging: PkgData
    public: PkgData


class PkgInfo(BaseModel):
    bootstrap: BootstrapGroup
    oem: OemGroup
    old_desc: str
    new_desc: str
    product_names: list


meta_pattern = re.compile(r"oem-([^-]*)-(.*)-meta")
market_name_pattern = re.compile(
    r"Description.*: hardware support for (Dell|HP|Lenovo) (.*)"
)

parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="""
You need to have the [oem-scripts] section in ~/.config/oem-scripts/config.ini.
Executing `launchpad-api get people/+me` will generate it.

For example,

[oem-scripts]
oauth_token = 8fbDontUseThis183c8f
oauth_token_secret = 6f8174257ThisWontWork9advfQLcngxT7TNgdfs7cbe709ce13458787ae547418faf57a8c9ca162h
oauth_consumer_key = System-wide: Ubuntu (oem-scripts machine)

Then you need to manually config the [private] section in ~/.config/oem-scripts/config.ini after the [oem-scripts] section to use the private archives.

For example,

[private]
url = SomewhereToProvideTheInformationForUsernameAndPassword
username = UserName
password = PassWord
archive = https://cesg.canonical.com/canonical
fingerprint = 54F1860295829CE3""",
)


parser.add_argument("-d", "--debug", help="print debug messages", action="store_true")
parser.add_argument(
    "-q", "--quiet", help="Don't print info messages", action="store_true"
)
parser.add_argument(
    "-v", "--verbose", action="store_true", help="print verbose messages"
)
parser.add_argument("--dry-run", help="Dry run the process.", action="store_true")
parser.add_argument("--yes", help="Say yes for all prompts.", action="store_true")
parser.add_argument("--apt-dir", type=str, help="specify the dir for apt")
series = lsb_release.get_os_release()["CODENAME"]
parser.add_argument(
    "--series",
    help=f"Specify the series codename, such as focal or jammy. ('{series}' by default)",
)


subparsers = parser.add_subparsers(dest="subcommand")

collect = subparsers.add_parser(
    "collect",
    help="[-h] oem-qemu-meta [-o|--output oem-qemu-meta.json]",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="""
For example,
    oem-meta-packages collect oem-qemu-meta [--output oem-qemu-meta.json]

Collect the information of OEM metapackages in PPAs and devel/staging archives.""",
)

collect.add_argument(
    "meta",
    help="Specify the meta package name or the meta json file to collect the information.",
)
collect.add_argument(
    "-o",
    "--output",
    help="Specify a filename to write the meta information.",
    type=argparse.FileType("w", encoding="UTF-8"),
)

list_pkg = subparsers.add_parser(
    "list",
    help="[-h]",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="List all OEM meta packages in Ubuntu archive.",
)

subscribe = subparsers.add_parser(
    "subscribe",
    help="[-h] [--meta oem-qemu-meta]",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=f"""
Make all bugs of all oem meta packages be subscribed by {SUBSCRIBER}.
 (search current apt source for package lists)

Check "To all bugs in oem-qemu-meta in Ubuntu:" on https://launchpad.net/ubuntu/+source/oem-qemu-meta/+subscribe for example.
Make all bugs of all oem meta packages be subscribed by {SUBSCRIBER}.
 (search current apt source for package lists)

Check "To all bugs in oem-qemu-meta in Ubuntu:" on https://launchpad.net/ubuntu/+source/oem-qemu-meta/+subscribe for example.

Or you can specify the single OEM metapackage to subscribe by using '--meta'.
""",
)
subscribe.add_argument("--meta", help="Specify the meta package to subscribe.")

unsubscribe = subparsers.add_parser(
    "unsubscribe",
    help="[-h] pkgName",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=f"""
Unsubscribe {SUBSCRIBER} from oem-qemu-meta

For example,
    oem-meta-packages unsubscribe oem-qemu-meta
""",
)
unsubscribe.add_argument(
    "pkgName", type=str, help="Specify the package name to unsubscribe."
)

staging_copy = subparsers.add_parser(
    "staging-copy",
    help="[-h] [--ignore-staging-lock] oem-qemu-meta",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="""
For example,
    oem-meta-packages --dry-run staging-copy oem-qemu-meta

Copy the meta package from the devel archive into the staging archive.""",
)

staging_copy.add_argument("meta", help="Specify the meta package to copy.")
staging_copy.add_argument(
    "--ignore-staging-lock", help="Ignore the staging-lock tag.", action="store_true"
)
staging_copy.add_argument(
    "--tag", help="Specify the tag when creating the cloudberry bug.", type=str
)

update = subparsers.add_parser(
    "update",
    help="[-h] oem-qemu-meta",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="""
For example,
    oem-meta-packages --dry-run update oem-qemu-meta --kernel linux-oem-20.04

Update the market name and the kernel flavour of the OEM meta package to the default kernel flavour, i.e. linux-generic-hwe-20.04.""",
)
update.add_argument(
    "meta",
    type=str,
    help="Specify the meta package name or the meta json file to update the meta package.",
)
update.add_argument(
    "--kernel",
    choices=ALLOWED_KERNEL_META_LIST,
    default="linux-generic-hwe-20.04",
    help="Specify the kernel meta to update.",
)
update.add_argument(
    "--factory",
    action="store_true",
    help="Make the factory meta to depend on the kernel meta directly.",
)

args = parser.parse_args()
BASEDIR = os.getcwd()

setup_logging(debug=args.debug, quiet=args.quiet)

if args.subcommand:
    login = LaunchpadLogin()
    lp = login.lp
    oem_archive = lp.people["oem-archive"]

if args.apt_dir:
    apt_pkg.init_config()
    if args.debug:
        old = apt_pkg.config.dump()
    apt_pkg.config.set("Dir", args.apt_dir)
    apt_pkg.config.set(
        "Dir::State::status", os.path.join(args.apt_dir, "var/lib/dpkg/status")
    )
    if args.debug:
        new = apt_pkg.config.dump()
        d = difflib.Differ()
        diff = d.compare(old.split("\n"), new.split("\n"))
        for line in diff:
            debug(line.strip())
    apt_pkg.init_system()


def get_animal(series: str) -> str:
    return list(
        filter(
            lambda x: series in x,
            map(
                lambda x: x.lower(),
                map(lambda x: x.codename, udi.supported(result="object")),
            ),
        )
    )[0].split(" ")[1]


udi = UbuntuDistroInfo()
if args.series:
    if not udi.valid(args.series):
        raise Exception(f"'{args.series}' is not a valid codename.")
    series = args.series
animal = get_animal(series)


def yes_or_ask(yes: bool, message: str) -> bool:
    if yes:
        print(f"> \033[1;34m{message}\033[1;0m (y/n) y")
        return True
    while True:
        res = input(f"> \033[1;34m{message}\033[1;0m (y/n) ").lower()
        if res not in {"y", "n"}:
            continue
        if res == "y":
            return True
        else:
            return False


def _debug_obj(pkg) -> None:

    if not args.debug:
        return

    debug(dir(pkg))

    for attr in dir(pkg):
        if not attr.startswith("__"):
            if not isinstance(pkg.__getattribute__(attr), types.BuiltinFunctionType):
                debug(f"{attr}: {pkg.__getattribute__(attr)}")


def get_oem_meta_packages(cache) -> list:
    pkg_list = []
    for pkg in cache.packages:
        name = pkg.name
        if (
            not name.startswith("oem-")
            or not name.endswith("-meta")
            or "-factory-" in name
        ):
            continue
        pkg_list.append(name)
    return sorted(pkg_list)


def _grouping_market_names(market_names: list, maxsplit=1) -> str:
    # Remove empty item
    while "" in market_names:
        market_names.remove("")
    tmp = collections.defaultdict(list)
    space_in_model = False
    try:
        for market_name in sorted(market_names):
            if maxsplit == 1:
                name, model = market_name.split(maxsplit=maxsplit)
                tmp[name].append(model)
                if " " in model:
                    space_in_model = True
            elif maxsplit == 2:
                brand, name, model = market_name.split(maxsplit=maxsplit)
                tmp[brand + " " + name].append(model)
                if " " in model:
                    space_in_model = True
    except ValueError:
        return ", ".join(sorted(market_names))

    if space_in_model:
        return ", ".join(f"{name} {', '.join(models)}" for name, models in tmp.items())
    else:
        return ", ".join(f"{name} {'/'.join(models)}" for name, models in tmp.items())


def deal_with_description(git_dir, old, new, product_names, project) -> bool:
    if project == "somerville":
        customer = "Dell"
    elif project == "stella":
        customer = "HP"
    elif project == "sutton":
        customer = "Lenovo"
    else:
        print(f"{project} is not supported.")
        exit(1)
    if not old or not new:
        return False
    os.chdir(git_dir)
    file_path = os.path.join(git_dir, "debian", "control")
    with open(file_path, "r") as control:
        lines = control.readlines()
    changed = False
    for i, line in enumerate(lines):
        if old in line:
            changed = True
            lines[i] = line.replace(old, new)
    info(f'"{old}" will be replaced by "{new}".')
    if len(product_names) > 0:
        newlines = []
        old_desc = False
        for line in lines:
            if line.startswith(" This is a metapackage for") and line.endswith(
                "It installs\n"
            ):
                old_desc = True
            elif line.endswith("packages needed to support this hardware fully.\n"):
                if old_desc is True:
                    changed = True
                    if len(product_names) > 1:
                        newlines.append(f" This is a metapackage for {customer} PCs:\n")
                    else:
                        newlines.append(f" This is a metapackage for {customer} PC:\n")
                    for product_name in product_names:
                        if customer not in product_name:
                            newlines.append(f"  * {customer} {product_name}\n")
                        else:
                            newlines.append(f"  * {product_name}\n")
                newlines.append(line)
            elif line.startswith(" This is a factory metapackage for"):
                old_desc = True
            elif line.endswith(
                "packages needed to support this hardware fully. (factory)\n"
            ):
                if old_desc is True:
                    changed = True
                    if len(product_names) > 1:
                        newlines.append(
                            f" This is a factory metapackage for {customer} PCs:\n"
                        )
                    else:
                        newlines.append(
                            f" This is a factory metapackage for {customer} PC:\n"
                        )
                    for product_name in product_names:
                        if customer not in product_name:
                            newlines.append(f"  * {customer} {product_name}\n")
                        else:
                            newlines.append(f"  * {product_name}\n")
                newlines.append(line)
            else:
                newlines.append(line)
        lines = newlines
        newlines = []
        for line in lines:
            if line.startswith(f" This is a metapackage for {customer} PC"):
                if len(product_names) > 1:
                    newlines.append(f" This is a metapackage for {customer} PCs:\n")
                else:
                    newlines.append(f" This is a metapackage for {customer} PC:\n")
            elif line.startswith(f" This is a factory metapackage for {customer} PC"):
                if len(product_names) > 1:
                    newlines.append(
                        f" This is a factory metapackage for {customer} PCs:\n"
                    )
                else:
                    newlines.append(
                        f" This is a factory metapackage for {customer} PC:\n"
                    )
            elif line.startswith(" * "):
                # Filter out product name not in the list
                for product_name in product_names:
                    if f"{product_name}\n" in line:
                        newlines.append(line)
                        break
            else:
                newlines.append(line)
        lines = newlines
    with open(file_path, "w") as control:
        control.writelines(lines)
    _run_command(["git", "add", "debian/control"])
    return changed


def deal_with_kernel_flavour(pkg_name, branch, git_dir) -> bool:
    os.chdir(git_dir)
    idx = -1
    kernel_flavour = None
    file_path = os.path.join(git_dir, "debian", "control")
    with open(file_path, "r") as control:
        lines = control.readlines()
    for i, line in enumerate(lines):
        if line.startswith("XB-Ubuntu-OEM-Kernel-Flavour:"):
            kernel_flavour = line[len("XB-Ubuntu-OEM-Kernel-Flavour:") :].strip()
            idx = i
            break

    if not kernel_flavour:
        critical(
            f"There is no XB-Ubuntu-OEM-Kernel-Flavour in debian/control of {branch} for {pkg_name}."
        )
        exit(1)

    debug(f"XB-Ubuntu-OEM-Kernel-Flavour: {kernel_flavour}")

    if (
        args.kernel.startswith("linux-generic")
        and args.kernel in ALLOWED_KERNEL_META_LIST
    ):
        if kernel_flavour == "default":
            return False
        kernel_flavour = "default"
    elif (
        args.kernel.startswith("linux-oem") and args.kernel in ALLOWED_KERNEL_META_LIST
    ):
        if kernel_flavour == "oem":
            return False
        kernel_flavour = "oem"
    else:
        print(f"{args.kernel} is not supported.")
        exit(1)

    lines[idx] = f"XB-Ubuntu-OEM-Kernel-Flavour: {kernel_flavour}\n"
    with open(file_path, "w") as control:
        control.writelines(lines)
    _run_command(["git", "add", "debian/control"])
    return True


def deal_with_kernel_depends(pkg_name, branch, git_dir) -> bool:
    os.chdir(git_dir)
    idx = -1
    file_path = os.path.join(git_dir, "debian", "control")
    changed = False
    with open(file_path, "r") as control:
        lines = control.readlines()
    for i, line in enumerate(lines):
        if line.startswith("Depends:"):
            idx = i
            break

    if idx == -1:
        critical("It can not find 'Depends' in debian/control.")
        exit(1)

    debug(lines[idx].strip())

    # this only works for updating auto-generated code
    if (
        args.kernel == "linux-oem-20.04b"
        and ", linux-oem-20.04b | linux-oem-20.04," not in lines[idx]
    ):
        for kernel in ALLOWED_KERNEL_META_LIST:
            prev = lines[idx]
            lines[idx] = lines[idx].replace(
                f", {kernel},", ", linux-oem-20.04b | linux-oem-20.04,"
            )
            if prev != lines[idx]:
                changed = True
    elif f", {args.kernel}," not in lines[idx]:
        lines[idx] = lines[idx].replace(
            ", linux-oem-20.04b | linux-oem-20.04,", f", {args.kernel},"
        )
        for kernel in ALLOWED_KERNEL_META_LIST:
            if kernel != args.kernel:
                lines[idx] = lines[idx].replace(f", {kernel},", f", {args.kernel},")
        changed = True

    if args.factory:
        factory_idx = -1
        # Find the factory depends.
        for i, line in enumerate(lines):
            if i > idx and line.startswith("Depends:"):
                factory_idx = i
                depends_line = lines[factory_idx].strip()
                break

        if factory_idx == -1:
            critical("It can not find factory 'Depends' in debian/control.")
            exit(1)

        for kernel in ALLOWED_KERNEL_META_LIST:
            if depends_line.endswith(kernel) or f"{kernel}," in depends_line:
                if kernel != args.kernel:
                    lines[factory_idx] = lines[factory_idx].replace(kernel, args.kernel)
                    changed = True
                break
        else:
            lines[factory_idx] = depends_line + f", {args.kernel}\n"
            changed = True

    with open(file_path, "w") as control:
        control.writelines(lines)

    if changed:
        _run_command(["git", "add", "debian/control"])

    return changed


def deal_with_debian_modaliases(git_dir: str) -> bool:
    debian_modaliases = os.path.join(git_dir, "debian", "modaliases")

    with open(debian_modaliases, "r") as f:
        modaliases = f.readlines()

    changed = False
    for i, modalias in enumerate(modaliases):
        if "bc0Csc05*" not in modalias:
            changed = True
            modaliases[i] = modalias.replace("* meta oem-", "bc0Csc05* meta oem-")

    if changed:
        with open(debian_modaliases, "w") as f:
            f.writelines(modaliases)

    return changed


def deal_with_debian_tests(
    pkg_name: str, git_dir: str, branch: str, bootstrap: bool
) -> bool:
    os.chdir(git_dir)

    changed = False

    tests_folder = os.path.join(git_dir, "debian", "tests")
    if not os.path.exists(tests_folder):
        os.mkdir(tests_folder)

    control_content = """Tests: meta
Depends: @
Restrictions: needs-root
"""
    control = os.path.join(git_dir, "debian", "tests", "control")

    if os.path.exists(control):
        with open(control, "r") as f:
            if f.read() != control_content:
                with open(control, "w") as fp:
                    fp.write(control_content)
                _run_command(["git", "add", "debian/tests/control"])
                changed = True
    else:
        with open(control, "w") as fp:
            fp.write(control_content)
        _run_command(["git", "add", "debian/tests/control"])
        changed = True

    meta_content = """#!/bin/bash

exec 2>&1
set -euo pipefail
IFS=$'\\n\\t'

apt-get update
apt-get full-upgrade --yes

apt-get update
apt-get full-upgrade --yes
"""
    if not bootstrap:
        if "oem" in args.kernel:
            grub_flavour = "oem"
        else:
            grub_flavour = "generic"
        meta_content += (
            "\ngrep ^GRUB_FLAVOUR_ORDER="
            + grub_flavour
            + "$ /etc/default/grub.d/oem-flavour.cfg\n"
        )
        meta_content += (
            "\ndpkg-query -W -f='${Status}' "
            + args.kernel
            + ' | grep "install ok installed"\n'
        )
    meta_content += f"\napt-get autoremove --purge --yes {pkg_name}\n"
    meta = os.path.join(git_dir, "debian", "tests", "meta")
    old_meta = os.path.join(git_dir, "debian", "tests", pkg_name)

    if os.path.exists(old_meta):
        _run_command(["git", "rm", "-f", f"debian/tests/{pkg_name}"])
        changed = True

    if os.path.exists(meta):
        with open(meta, "r") as f:
            if f.read() != meta_content:
                with open(meta, "w") as fp:
                    fp.write(meta_content)
                _run_command(["git", "add", "debian/tests/meta"])
                changed = True
    else:
        with open(meta, "w") as fp:
            fp.write(meta_content)
        _run_command(["git", "add", "debian/tests/meta"])
        changed = True

    return changed


def deal_with_gbp_conf(git_dir, branch) -> bool:
    os.chdir(git_dir)
    file_path = os.path.join(git_dir, "debian", "gbp.conf")
    gbp_conf = f"""[DEFAULT]
pristine-tar = False
debian-branch = {branch}
debian-tag = {branch}_%(version)s
"""
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            if f.read() == gbp_conf:
                return False
    with open(file_path, "w") as f:
        f.write(gbp_conf)
    _run_command(["git", "add", "debian/gbp.conf"])
    return True


def deal_with_maintainer_scripts(pkg_name, branch, git_dir) -> bool:
    postinst_path = os.path.join(git_dir, "debian", "postinst")
    postrm_path = os.path.join(git_dir, "debian", "postrm")
    modified = False

    with open(postinst_path, "w") as f:
        f.write(
            f"""#!/bin/sh

set -e

. /usr/share/debconf/confmodule

case "$1" in
    configure)
        mkdir -p /etc/default/grub.d/
        ln -sf /usr/share/{pkg_name}/oem-flavour.cfg /etc/default/grub.d/oem-flavour.cfg
        if [ -e /boot/grub/grub.cfg ] && command -v update-grub; then
            update-grub
        fi
    ;;
esac

#DEBHELPER#
"""
        )
    _run_command(["git", "add", "debian/postinst"])
    output, _, _ = _run_command(["git", "status", "--porcelain", "debian/postinst"])
    if output:
        modified = True

    with open(postrm_path, "w") as f:
        f.write(
            """#!/bin/sh

set -e

. /usr/share/debconf/confmodule

case "$1" in
    remove|purge)
        rm -f /etc/default/grub.d/oem-flavour.cfg
        if [ -e /boot/grub/grub.cfg ] && command -v update-grub; then
            update-grub
        fi
    ;;
esac

#DEBHELPER#
"""
        )
    _run_command(["git", "add", "debian/postrm"])
    output, _, _ = _run_command(["git", "status", "--porcelain", "debian/postrm"])
    if output:
        modified = True

    return modified


def deal_with_grub_flavour(pkg_name, branch, git_dir) -> bool:
    os.chdir(git_dir)
    grub_flavour = None
    file_path = os.path.join(git_dir, "oem-flavour.cfg")
    if os.path.exists(file_path):
        with open(file_path, "r") as oem_flavour:
            for line in oem_flavour:
                if line.startswith("GRUB_FLAVOUR_ORDER="):
                    grub_flavour = line[len("GRUB_FLAVOUR_ORDER=") :].strip()
                    break

    if (
        args.kernel.startswith("linux-generic")
        and args.kernel in ALLOWED_KERNEL_META_LIST
    ):
        if grub_flavour == "generic":
            return False
        grub_flavour = "generic"
    elif (
        args.kernel.startswith("linux-oem") and args.kernel in ALLOWED_KERNEL_META_LIST
    ):
        if grub_flavour == "oem":
            return False
        grub_flavour = "oem"
    else:
        print(f"{args.kernel} is not supported.")
        exit(1)

    if not os.path.exists(file_path):
        with open(os.path.join(git_dir, "debian", "install"), "a") as f:
            f.write(f"oem-flavour.cfg /usr/share/{pkg_name}/\n")
        _run_command(["git", "add", "debian/install"])

    with open(file_path, "w") as f:
        f.write(
            f"""# This file is automatically generated by {pkg_name}, and changes will be overriden
GRUB_FLAVOUR_ORDER={grub_flavour}
"""
        )
    _run_command(["git", "add", "oem-flavour.cfg"])

    return True


# Python 3.9 supports this.
def remove_prefix(s, prefix):
    return s[len(prefix) :] if s.startswith(prefix) else s


# Python 3.9 supports this.
def remove_suffix(s, suffix):
    return s[: -len(suffix)] if s.endswith(suffix) else s


def remove_prefix_suffix(s, prefix, suffix):
    return remove_suffix(remove_prefix(s, prefix), suffix)


class OemMetaPkgInfo(metaclass=ABCMeta):
    def __init__(self, meta):
        self.meta = meta
        self.project = None
        self.group = None
        self.platform = None
        self.pkg_data = None
        self.version = ""
        self.archive = ""
        self.kernel_flavour = ""
        self.kernel_meta = ""
        self.fingerprint = ""
        self.market_name = ""
        self.parse_meta_name()
        self.get_info()
        info(
            f"{self.__class__.__name__} ({self.version}, {self.kernel_flavour}, {self.kernel_meta}, {self.archive}, {self.market_name})"
        )

    def get_data(self):
        if self.pkg_data is None:
            self.pkg_data = PkgData(
                version=self.version,
                archive=self.archive,
                kernel_flavour=self.kernel_flavour,
                kernel_meta=self.kernel_meta,
                fingerprint=self.fingerprint,
                market_name=self.market_name,
            )
        return self.pkg_data

    def parse_meta_name(self):
        result = meta_pattern.match(self.meta)
        if not result:
            raise Exception(f"oem-([^-]*)-(.*)-meta is not matched to {self.meta}")
        if "." in result.group(1):
            self.project, self.group = result.group(1).split(".")
        else:
            self.project = result.group(1)
            self.group = None

        self.platform = result.group(2)
        if self.group:
            self.ubuntu_branch = f"{self.group}.{self.platform}-{series}-ubuntu"
            self.oem_branch = f"{self.group}.{self.platform}-{series}-oem"
        else:
            self.ubuntu_branch = f"{self.platform}-{series}-ubuntu"
            self.oem_branch = f"{self.platform}-{series}-oem"

    @classmethod
    def get_market_name(cls, control):
        if type(control) is str:
            control = control.split("\n")
        for line in control:
            if line.startswith("Description:") or line.startswith("Description-en:"):
                if (
                    "Dell" in line or "HP" in line or "Lenovo" in line
                ) and "(factory)" not in line:
                    result = market_name_pattern.match(line.strip())
                    return result.group(2)
        return ""

    @abstractmethod
    def get_info(self):
        raise NotImplementedError("Must override get_info()")


class BootstrapFromGit(OemMetaPkgInfo):
    def get_info(self):
        self.get_version()
        self.archive = ""
        self.get_kernel_flavour_meta()

    def get_version(self):
        wget_changelog_command = (
            "wget",
            "-q",
            "-O",
            "changelog",
            f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{self.project}-projects-meta/plain/debian/changelog?h={self.ubuntu_branch}",
        )

        with TemporaryDirectory() as tmpdir:
            os.chdir(tmpdir)
            _run_command(wget_changelog_command)
            self.version, _, _ = _run_command(
                ["dpkg-parsechangelog", "--show-field", "Version", "-l", "changelog"]
            )

    def get_kernel_flavour_meta(self):
        wget_control_command = (
            "wget",
            "-q",
            "-O",
            "control",
            f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{self.project}-projects-meta/plain/debian/control?h={self.ubuntu_branch}",
        )

        bootstrap_kernel_flavour = None
        with TemporaryDirectory() as tmpdir:
            os.chdir(tmpdir)
            _run_command(wget_control_command)
            bootstrap_kernel_flavour, _, _ = _run_command(
                ["grep", "^XB-Ubuntu-OEM-Kernel-Flavour", "control"]
            )
            for kernel_meta in ALLOWED_KERNEL_META_LIST:
                kernel_flavour, _, returncode = _run_command(
                    ["grep", f"\b{kernel_meta}\b", "control"],
                    returncode=(0, 1),
                    silent=True,
                )
                if returncode == 0:
                    error(
                        f"{self.project} {self.ubuntu_branch} debian/control should not contain {kernel_flavour}."
                    )
                    exit(1)
            else:
                self.kernel_meta = ""

            with open("control") as control:
                self.market_name = self.get_market_name(control)

        if bootstrap_kernel_flavour == "XB-Ubuntu-OEM-Kernel-Flavour: oem":
            self.kernel_flavour = "oem"
        elif bootstrap_kernel_flavour == "XB-Ubuntu-OEM-Kernel-Flavour: default":
            self.kernel_flavour = "default"
        else:
            raise Exception(
                f"XB-Ubuntu-OEM-Kernel-Flavour in invalid for {self.ubuntu_branch} of {self.project}"
            )


class BootstrapFromPPA(OemMetaPkgInfo):
    def get_info(self):
        self.archive = "ppa:canonical-oem-metapackage-uploaders/oem-metapackage-staging"
        self.fingerprint = "EA7BFBE3B33B9D51D225430EC83677AEDFC29884"
        with TemporaryDirectory() as tmpdir:
            _run_command(
                [
                    "setup-apt-dir.sh",
                    "-c",
                    series,
                    "--ppa",
                    self.archive,
                    "--disable-base",
                    "--disable-updates",
                    "--disable-backports",
                    "--apt-dir",
                    tmpdir,
                ],
                silent=True,
            )
            self.get_version(tmpdir)
            self.get_kernel_flavour_meta(tmpdir)

    def get_version(self, tmpdir):
        ppa_version = ""
        output, _, _ = _run_command(
            ["pkg-list", "--long", "--apt-dir", tmpdir, self.meta],
            returncode=(0, 1),
            silent=True,
        )
        for line in output.split("\n"):
            if self.meta in line and "http://ppa.launchpad.net/ubuntu" in line:
                ppa_version = line.split(" ")[1]
                break
        self.version = ppa_version

    def get_kernel_flavour_meta(self, tmpdir):
        output, _, returncode = _run_command(
            [
                "apt-cache",
                "-o",
                f"Dir={tmpdir}",
                "-o",
                f"Dir::State::status={tmpdir}/var/lib/dpkg/status",
                "show",
                f"{self.meta}={self.version}",
            ],
            returncode=(0, 100),
            silent=True,
        )

        if returncode == 100:
            return

        self.market_name = self.get_market_name(output)

        for line in output.split("\n"):
            if line.startswith("Ubuntu-Oem-Kernel-Flavour:"):
                self.kernel_flavour = line.split(" ")[1]
            if line.startswith("Depends:"):
                for kernel_meta in ALLOWED_KERNEL_META_LIST:
                    if kernel_meta in line:
                        error(
                            f"{self.meta}'s debian/control in Ubuntu archive should not depend on {kernel_meta}."
                        )
                        exit(1)


class BootstrapFromProposedArchive(OemMetaPkgInfo):
    def get_info(self):
        self.archive = f"ubuntu:{series}-proposed"
        with TemporaryDirectory() as tmpdir:
            os.chdir(tmpdir)
            _run_command(
                [
                    "setup-apt-dir.sh",
                    "-c",
                    series,
                    "--proposed",
                    "--disable-base",
                    "--disable-updates",
                    "--disable-backports",
                    "--apt-dir",
                    tmpdir,
                ],
                silent=True,
            )
            self.get_version(tmpdir)
            self.get_kernel_flavour_meta(tmpdir)

    def get_version(self, tmpdir):
        proposed_version = ""
        output, _, _ = _run_command(
            ["pkg-list", "--long", "--apt-dir", tmpdir, self.meta],
            returncode=(0, 1),
            silent=True,
        )
        for line in output.split("\n"):
            if self.meta in line and "http://archive.ubuntu.com/ubuntu" in line:
                proposed_version = line.split(" ")[1]
                break
        self.version = proposed_version

    def get_kernel_flavour_meta(self, tmpdir):
        output, _, returncode = _run_command(
            [
                "apt-cache",
                "-o",
                f"Dir={tmpdir}",
                "-o",
                f"Dir::State::status={tmpdir}/var/lib/dpkg/status",
                "show",
                f"{self.meta}={self.version}",
            ],
            returncode=(0, 100),
            silent=True,
        )

        if returncode == 100:
            return

        self.market_name = self.get_market_name(output)

        for line in output.split("\n"):
            if line.startswith("Ubuntu-Oem-Kernel-Flavour:"):
                self.kernel_flavour = line.split(" ")[1]
            if line.startswith("Depends:"):
                for kernel_meta in ALLOWED_KERNEL_META_LIST:
                    if kernel_meta in line:
                        error(
                            f"{self.meta}'s debian/control in Ubuntu archive should not depend on {kernel_meta}."
                        )
                        exit(1)


class BootstrapFromUbuntuArchive(OemMetaPkgInfo):
    def get_info(self):
        self.archive = f"ubuntu:{series}|{series}-updates"
        with TemporaryDirectory() as tmpdir:
            _run_command(
                [
                    "setup-apt-dir.sh",
                    "-c",
                    series,
                    "--disable-backports",
                    "--apt-dir",
                    tmpdir,
                ],
                silent=True,
            )
            self.get_version(tmpdir)
            self.get_kernel_flavour_meta(tmpdir)

    def get_version(self, tmpdir):
        ubuntu_version = ""
        output, _, _ = _run_command(
            ["pkg-list", "--long", "--apt-dir", tmpdir, self.meta],
            returncode=(0, 1),
            silent=True,
        )
        for line in output.split("\n"):
            if self.meta in line and "http://archive.ubuntu.com/ubuntu" in line:
                ubuntu_version = line.split(" ")[1]
                break
        self.version = ubuntu_version

    def get_kernel_flavour_meta(self, tmpdir):
        output, _, returncode = _run_command(
            [
                "apt-cache",
                "-o",
                f"Dir={tmpdir}",
                "-o",
                f"Dir::State::status={tmpdir}/var/lib/dpkg/status",
                "show",
                f"{self.meta}={self.version}",
            ],
            returncode=(0, 100),
            silent=True,
        )

        if returncode == 100:
            return

        self.market_name = self.get_market_name(output)

        for line in output.split("\n"):
            if line.startswith("Ubuntu-Oem-Kernel-Flavour:"):
                self.kernel_flavour = line.split(" ")[1]
            if line.startswith("Depends:"):
                for kernel_meta in ALLOWED_KERNEL_META_LIST:
                    if kernel_meta in line:
                        error(
                            f"{self.meta}'s debian/control in Ubuntu archive should not depend on {kernel_meta}."
                        )
                        exit(1)


class OemFromGit(OemMetaPkgInfo):
    def get_info(self):
        self.get_version()
        self.archive = ""
        self.get_kernel_flavour_meta()

    def get_version(self):
        wget_changelog_command = (
            "wget",
            "-q",
            "-O",
            "changelog",
            f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{self.project}-projects-meta/plain/debian/changelog?h={self.oem_branch}",
        )

        with TemporaryDirectory() as tmpdir:
            os.chdir(tmpdir)
            _run_command(wget_changelog_command)
            self.version, _, _ = _run_command(
                ["dpkg-parsechangelog", "--show-field", "Version", "-l", "changelog"]
            )

    def get_kernel_flavour_meta(self):
        wget_control_command = (
            "wget",
            "-q",
            "-O",
            "control",
            f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{self.project}-projects-meta/plain/debian/control?h={self.oem_branch}",
        )

        with TemporaryDirectory() as tmpdir:
            os.chdir(tmpdir)
            _run_command(wget_control_command)
            oem_kernel_flavour, _, _ = _run_command(
                ["grep", "^XB-Ubuntu-OEM-Kernel-Flavour", "control"]
            )
            for kernel_meta in ALLOWED_KERNEL_META_LIST:
                _, _, returncode = _run_command(
                    ["grep", f"\\b{kernel_meta}\\b", "control"], returncode=(0, 1)
                )
                if returncode == 0:
                    self.kernel_meta = kernel_meta
                    break
            else:
                error(
                    f"{self.project} {self.oem_branch} The kernel meta doesn't exist or it is not in the allowed list."
                )

            with open("control") as control:
                self.market_name = self.get_market_name(control)

        if oem_kernel_flavour == "XB-Ubuntu-OEM-Kernel-Flavour: oem":
            self.kernel_flavour = "oem"
        elif oem_kernel_flavour == "XB-Ubuntu-OEM-Kernel-Flavour: default":
            self.kernel_flavour = "default"
        else:
            raise Exception(
                f"XB-Ubuntu-OEM-Kernel-Flavour is invalid for {self.oem_branch} of {self.project}"
            )


class OemFromPPA(OemMetaPkgInfo):
    def get_info(self):
        self.get_version_archive()
        self.get_kernel_flavour_meta()

    def get_version_archive(self, archive_name=None):
        if archive_name:
            archive = oem_archive.getPPAByName(name=archive_name)
        elif self.project == "somerville":
            try:
                archive = oem_archive.getPPAByName(
                    name=f"{self.project}-{animal}-{self.platform}"
                )
            except lazr.restfulclient.errors.NotFound:
                archive = oem_archive.getPPAByName(
                    name=f"{self.project}-{self.platform}"
                )
        elif self.project == "stella":
            if series == "focal":
                archive = oem_archive.getPPAByName(
                    name=f"{self.project}-{self.group}-ouagadougou"
                )
            else:
                archive = oem_archive.getPPAByName(name=self.project)
        elif self.project == "sutton":
            try:
                if series == "focal":
                    archive = oem_archive.getPPAByName(
                        name=f"{self.project}-{self.group}-ouagadougou"
                    )
                else:
                    archive = oem_archive.getPPAByName(name=self.project)
            except lazr.restfulclient.errors.NotFound:
                archive = oem_archive.getPPAByName(name=f"{self.project}-{self.group}")
        source_lists = "\n".join(lp.me.getArchiveSubscriptionURLs())
        while f"oem-archive/{archive.name}/ubuntu" not in source_lists:
            info(f"Subscribing ppa:oem-archive/{archive.name}")
            try:
                archive.newSubscription(subscriber=lp.me)
                archive.lp_save()
            except lazr.restfulclient.errors.BadRequest as e:
                if "already has a current subscription for" not in str(e):
                    raise e
            _run_command(["get-private-ppa", f"ppa:oem-archive/{archive.name}"])
            source_lists = "\n".join(lp.me.getArchiveSubscriptionURLs())
        sources = archive.getPublishedSources(exact_match=True, source_name=self.meta)
        fingerprint = archive.signing_key_fingerprint
        version = ""  # apt_pkg.version_compare doesn't accept NoneType
        for source in sources:
            debug(
                f"Checking ppa:oem-archive/{archive.name} {source.source_package_name} {source.source_package_version}"
            )
            if (
                source.source_package_name == self.meta
                and apt_pkg.version_compare(source.source_package_version, version) > 0
            ):
                version = source.source_package_version
                break
        if version:
            self.archive = f"ppa:oem-archive/{archive.name}"
            self.version = version
            self.fingerprint = fingerprint
            return

        if archive_name is None:
            self.get_version_archive(self.project)
        else:
            error(f"It can not find the PPA for {self.meta}.")
            exit(1)

    def get_kernel_flavour_meta(self):
        with TemporaryDirectory() as tmpdir:
            _run_command(
                [
                    "setup-apt-dir.sh",
                    "-c",
                    series,
                    "--ppa",
                    self.archive,
                    "--disable-base",
                    "--disable-updates",
                    "--disable-backports",
                    "--apt-dir",
                    tmpdir,
                ],
                silent=True,
            )

            output, _, returncode = _run_command(
                [
                    "apt-cache",
                    "-o",
                    f"Dir={tmpdir}",
                    "-o",
                    f"Dir::State::status={tmpdir}/var/lib/dpkg/status",
                    "show",
                    f"{self.meta}={self.version}",
                ],
                returncode=(0, 100),
                silent=True,
            )

            if returncode == 100:
                return

            self.market_name = self.get_market_name(output)

            for line in output.split("\n"):
                if line.startswith("Ubuntu-Oem-Kernel-Flavour:"):
                    self.kernel_flavour = line.split(" ")[1]
                if line.startswith("Depends:"):
                    for kernel_meta in ALLOWED_KERNEL_META_LIST:
                        if kernel_meta in line:
                            self.kernel_meta = kernel_meta
                            break
                    else:
                        error(
                            f"It can not find the kernel meta matched to ALLOWED_KERNEL_META_LIST in {self.meta}'s debian/control in {self.archive}."
                        )
                        exit(1)


class OemFromPrivateArchive(OemMetaPkgInfo):
    staging_pattern = re.compile(r".*>(.*)/</a>")

    def __init__(self, meta, index, config, branch):
        self._index = index
        self._config = config
        self._branch = branch
        super().__init__(meta)

    def get_info(self):
        self.fingerprint = self._config["fingerprint"]
        with TemporaryDirectory() as tmpdir:
            self.get_version_archive(tmpdir)
            if self.version:
                self.get_kernel_flavour_meta(tmpdir)

    def get_version_archive(self, tmpdir):
        index = self._index
        config = self._config
        domain = config["archive"].split("://")[1].split("/")[0]
        archive = ""
        version = ""
        if self.project == "somerville":
            codename = self.platform
        elif series != "focal":
            codename = self.project
        else:
            codename = self.group

        for line in index.split("\n"):
            if self.project in line and f"{codename}-{series}-{self._branch}" in line:
                result = self.staging_pattern.match(line)
                if result:
                    archive = result.group(1)
                    break

        if not archive:
            for line in index.split("\n"):
                if (
                    self.project in line
                    and codename in line
                    and f"{series}-{self._branch}" in line
                ):
                    result = self.staging_pattern.match(line)
                    if result:
                        archive = result.group(1)
                        break

        source_line = config["archive"].replace(
            "https://", f"https://{config['username']}:{config['password']}@"
        )
        _run_command(
            [
                "setup-apt-dir.sh",
                "-c",
                series,
                "--disable-updates",
                "--disable-backports",
                "--apt-dir",
                tmpdir,
                "--extra-key",
                config["fingerprint"],
                "--extra-repo",
                f"deb [signed-by={tmpdir}/{config['fingerprint']}.pub arch=amd64] {source_line} {archive} public",
            ],
            silent=True,
        )
        output, _, _ = _run_command(
            ["pkg-list", "--long", "--apt-dir", tmpdir, self.meta],
            returncode=(0, 1),
            silent=True,
        )
        for line in output.split("\n"):
            if self.meta in line and domain in line:
                version = line.split(" ")[1]
                break

        if not version and self.project == "somerville":
            archive = f"somerville-{series}-{self._branch}"
            source_line = config["archive"].replace(
                "https://", f"https://{config['username']}:{config['password']}@"
            )
            _run_command(
                [
                    "setup-apt-dir.sh",
                    "-c",
                    series,
                    "--disable-updates",
                    "--disable-backports",
                    "--apt-dir",
                    tmpdir,
                    "--extra-key",
                    config["fingerprint"],
                    "--extra-repo",
                    f"deb [signed-by={tmpdir}/{config['fingerprint']}.pub arch=amd64] {source_line} {archive} public",
                ],
                silent=True,
            )
            output, _, _ = _run_command(
                ["pkg-list", "--long", "--apt-dir", tmpdir, self.meta],
                returncode=(0, 1),
                silent=True,
            )
            for line in output.split("\n"):
                if self.meta in line and domain in line:
                    version = line.split(" ")[1]
                    break
        if version:
            self.archive = f"cesg:{archive}"
            self.version = version

    def get_kernel_flavour_meta(self, tmpdir):
        output, _, returncode = _run_command(
            [
                "apt-cache",
                "-o",
                f"Dir={tmpdir}",
                "-o",
                f"Dir::State::status={tmpdir}/var/lib/dpkg/status",
                "show",
                f"{self.meta}={self.version}",
            ],
            returncode=(0, 100),
            silent=True,
        )

        if returncode == 100:
            return

        self.market_name = self.get_market_name(output)

        for line in output.split("\n"):
            if line.startswith("Ubuntu-Oem-Kernel-Flavour:"):
                self.kernel_flavour = line.split(" ")[1]
            if line.startswith("Depends:"):
                for kernel_meta in ALLOWED_KERNEL_META_LIST:
                    if kernel_meta in line:
                        self.kernel_meta = kernel_meta
                        break
                else:
                    error(
                        f"It can not find the kernel meta matched to ALLOWED_KERNEL_META_LIST in {self.meta}'s debian/control in {self.archive}."
                    )
                    exit(1)


class OemFromDevelArchive(OemFromPrivateArchive):
    def __init__(self, meta, index, config):
        super().__init__(meta, index, config, "devel")


class OemFromStagingArchive(OemFromPrivateArchive):
    def __init__(self, meta, index, config):
        super().__init__(meta, index, config, "staging")


class OemFromPublicArchive(OemMetaPkgInfo):
    def get_info(self):
        self.fingerprint = "59AC787C2A8C78BA5ECA0B2ED4D1EAED36962F69"
        with TemporaryDirectory() as tmpdir:
            self.get_version_archive(tmpdir)
            self.get_kernel_flavour_meta(tmpdir)

    def get_version_archive(self, tmpdir):
        if self.project == "somerville":
            source_line = "http://dell.archive.canonical.com/"
            archive = f"somerville-{self.platform}"
        elif self.project == "stella":
            source_line = "http://hp.archive.canonical.com/"
            if series == "focal":
                archive = f"stella.{self.group}"
            else:
                archive = self.project
        elif self.project == "sutton":
            source_line = "http://lenovo.archive.canonical.com/"
            if series == "focal":
                archive = f"sutton.{self.group}"
            else:
                archive = self.project
        oem_version = ""
        _run_command(
            [
                "setup-apt-dir.sh",
                "-c",
                series,
                "--disable-base",
                "--disable-updates",
                "--disable-backports",
                "--apt-dir",
                tmpdir,
                "--extra-key",
                self.fingerprint,
                "--extra-repo",
                f"deb [signed-by={tmpdir}/{self.fingerprint}.pub arch=amd64] {source_line} {series} {archive}",
            ],
            silent=True,
        )
        output, _, _ = _run_command(
            ["pkg-list", "--long", "--apt-dir", tmpdir, self.meta],
            returncode=(0, 1),
            silent=True,
        )
        for line in output.split("\n"):
            if self.meta in line and source_line in line:
                oem_version = line.split(" ")[1]
                break
        self.version = oem_version
        self.archive = f"oem:{archive}"

    def get_kernel_flavour_meta(self, tmpdir):
        output, _, returncode = _run_command(
            [
                "apt-cache",
                "-o",
                f"Dir={tmpdir}",
                "-o",
                f"Dir::State::status={tmpdir}/var/lib/dpkg/status",
                "show",
                f"{self.meta}={self.version}",
            ],
            returncode=(0, 100),
            silent=True,
        )

        if returncode == 100:
            return

        self.market_name = self.get_market_name(output)

        for line in output.split("\n"):
            if line.startswith("Ubuntu-Oem-Kernel-Flavour:"):
                self.kernel_flavour = line.split(" ")[1]
            if line.startswith("Depends:"):
                for kernel_meta in ALLOWED_KERNEL_META_LIST:
                    if kernel_meta in line:
                        self.kernel_meta = kernel_meta
                        break
                else:
                    error(
                        f"It can not find the kernel meta matched to ALLOWED_KERNEL_META_LIST in {self.meta}'s debian/control in {self.archive}."
                    )
                    exit(1)


class OemMetaPkg(object):
    """This object contains all related information for OEM metapackages"""

    def __init__(self, meta, index, config):
        info(f"Checking {meta}...")
        self.oem = OemGroup(
            git=OemFromGit(meta).get_data(),
            ppa=OemFromPPA(meta).get_data(),
            devel=OemFromDevelArchive(meta, index, config).get_data(),
            staging=OemFromStagingArchive(meta, index, config).get_data(),
            public=OemFromPublicArchive(meta).get_data(),
        )
        self.bootstrap = BootstrapGroup(
            git=BootstrapFromGit(meta).get_data(),
            ppa=BootstrapFromPPA(meta).get_data(),
            proposed=BootstrapFromProposedArchive(meta).get_data(),
            ubuntu=BootstrapFromUbuntuArchive(meta).get_data(),
        )


def collect_pkg_info(
    data, check_private: bool = False, index=None, config=None
) -> dict:
    if type(data) is str:
        result = meta_pattern.match(data)

        if not result:
            print(f"{data} is not supported.")
            exit(1)

        if "." in result.group(1):
            project, group = result.group(1).split(".")
        else:
            project = result.group(1)
            group = None

        codename = result.group(2)
        debug(f"Project {project}, Group {group}, Codename {codename}.")

        if project == "somerville":
            customer = "Dell"
            tag = f"{animal}-{codename}"
            codename = tag
        elif project == "stella":
            customer = "HP"
            tag = ""
        elif project == "sutton":
            customer = "Lenovo"
            tag = ""
        else:
            print(f"{data} is not supported.")
            exit(1)

        json_data = json.loads(
            f"""{{
"Customer": "{customer}",
"Group": "{group}",
"Codename": "{codename}",
"Platform": "",
"MarketName": "",
"PlatformLPTag": "{tag}"
}}"""
        )
        json_data["ProductNames"] = []
    else:
        project = data.get("project")
        codename = data.get("platform")
        group = data.get("group")
        if project == "somerville":
            customer = "Dell"
            tag = animal + "-" + data.get("platform")
        elif project == "stella":
            customer = "HP"
            tag = ""
        elif project == "sutton":
            customer = "Lenovo"
            tag = ""
        else:
            print(f"{data} is not supported.")
            exit(1)

        json_data = json.loads(
            f"""{{
"Customer": "{customer}",
"Group": "{group}",
"Codename": "{codename}",
"Platform": "",
"MarketName": "",
"PlatformLPTag": "{tag}"
}}"""
        )

        if "productnames" in data:
            json_data["ProductNames"] = data["productnames"]

    debug(json.dumps(json_data, indent=4, sort_keys=True))

    somerville = dict()
    stella = dict()
    sutton = dict()

    customer = json_data["Customer"].lower()
    platform = json_data["Platform"].lower()
    codename = json_data["Codename"].lower()
    group = json_data["Group"].lower()
    market_name = json_data["MarketName"]
    lp_tag = json_data["PlatformLPTag"].lower()
    if "dell" in customer:
        platform = remove_prefix(lp_tag, f"{animal}-")
        lst = somerville.get(platform, [])
        lst.append(market_name)
        somerville[platform] = lst
    elif "hp" in customer:
        if series == "focal":
            lst = stella.get(f"{group}-{codename}", [])
            lst.append(market_name)
            stella[f"{group}-{codename}"] = lst
        else:
            lst = stella.get(codename, [])
            lst.append(market_name)
            stella[codename] = lst
    elif "lenovo" in customer:
        if series == "focal":
            lst = sutton.get(f"{group}-{codename}", [])
            lst.append(market_name)
            sutton[f"{group}-{codename}"] = lst
        else:
            lst = sutton.get(codename, [])
            lst.append(market_name)
            sutton[codename] = lst

    debug(f"Somerville market names {somerville}")
    debug(f"Stella market names {stella}")
    debug(f"Sutton market names {sutton}")

    pkgNamesInArchive = get_oem_meta_packages(cache)

    pkgInfo = dict()

    # Somerville
    for codename, v in somerville.items():
        pkg_name = "oem-somerville-" + codename + "-meta"

        meta = OemMetaPkg(pkg_name, index, config)

        pkgInfo[pkg_name] = PkgInfo(
            bootstrap=meta.bootstrap,
            oem=meta.oem,
            old_desc="",
            new_desc="",
            product_names=json_data["ProductNames"],
        )

        if pkg_name in pkgNamesInArchive and "".join(v):
            new_desc = _grouping_market_names(v)
            if "Dell" not in new_desc:
                new_desc = "Dell " + new_desc
            pkgInfo[pkg_name].old_desc = f"Somerville {codename.title()} platform"
            pkgInfo[pkg_name].new_desc = new_desc

        if meta.bootstrap.git.market_name:
            market_name = meta.bootstrap.git.market_name
        elif meta.oem.git.market_name:
            market_name = meta.oem.git.market_name
        else:
            market_name = ""

        if not pkgInfo[pkg_name].new_desc and market_name:
            pkgInfo[pkg_name].new_desc = f"Dell {market_name}"
            pkgInfo[pkg_name].old_desc = f"Somerville {codename.title()} platform"

    # Stella
    for k, v in stella.items():
        if series == "focal":
            pkg_name = "oem-stella." + k + "-meta"
        else:
            pkg_name = "oem-stella-" + k + "-meta"
        if series == "focal":
            group, codename = k.split("-", 1)
        else:
            codename = k

        meta = OemMetaPkg(pkg_name, index, config)

        pkgInfo[pkg_name] = PkgInfo(
            bootstrap=meta.bootstrap,
            oem=meta.oem,
            old_desc="",
            new_desc="",
            product_names=json_data["ProductNames"],
        )

        if pkg_name in pkgNamesInArchive and "".join(v):
            new_desc = _grouping_market_names(v, maxsplit=2)
            if "HP" not in new_desc:
                new_desc = "HP " + new_desc
            if series == "focal":
                pkgInfo[
                    pkg_name
                ].old_desc = f"Stella {group.title()} {codename.title()} platform"
            else:
                pkgInfo[pkg_name].old_desc = f"Stella {codename.title()} platform"
            pkgInfo[pkg_name].new_desc = new_desc

        if meta.bootstrap.git.market_name:
            market_name = meta.bootstrap.git.market_name
        elif meta.oem.git.market_name:
            market_name = meta.oem.git.market_name
        else:
            market_name = ""

        if not pkgInfo[pkg_name].new_desc and market_name:
            pkgInfo[pkg_name].new_desc = f"HP {market_name}"
            if series == "focal":
                pkgInfo[
                    pkg_name
                ].old_desc = f"Stella {group.title()} {codename.title()} platform"
            else:
                pkgInfo[pkg_name].old_desc = f"Stella {codename.title()} platform"

    # Sutton
    for k, v in sutton.items():
        if series == "focal":
            pkg_name = "oem-sutton." + k + "-meta"
        else:
            pkg_name = "oem-sutton-" + k + "-meta"
        if series == "focal":
            group, codename = k.split("-", 1)
        else:
            codename = k

        meta = OemMetaPkg(pkg_name, index, config)

        pkgInfo[pkg_name] = PkgInfo(
            bootstrap=meta.bootstrap,
            oem=meta.oem,
            old_desc="",
            new_desc="",
            product_names=json_data["ProductNames"],
        )

        if pkg_name in pkgNamesInArchive and "".join(v):
            new_desc = _grouping_market_names(v)
            if "Lenovo" not in new_desc:
                new_desc = "Lenovo " + new_desc
            if series == "focal":
                pkgInfo[
                    pkg_name
                ].old_desc = f"Sutton {group.title()} {codename.title()} platform"
            else:
                pkgInfo[pkg_name].old_desc = f"Sutton {codename.title()} platform"
            pkgInfo[pkg_name].new_desc = new_desc

        if meta.bootstrap.git.market_name:
            market_name = meta.bootstrap.git.market_name
        elif meta.oem.git.market_name:
            market_name = meta.oem.git.market_name
        else:
            market_name = ""

        if not pkgInfo[pkg_name].new_desc and market_name:
            pkgInfo[pkg_name].new_desc = f"Lenovo {market_name}"
            if series == "focal":
                pkgInfo[
                    pkg_name
                ].old_desc = f"Sutton {group.title()} {codename.title()} platform"
            else:
                pkgInfo[pkg_name].old_desc = f"Sutton {codename.title()} platform"

    debug(json.dumps(pkgInfo, indent=4, sort_keys=True, cls=CustomEncoder))

    return pkgInfo


def process_update_task(pkgInfo) -> None:
    debug(pkgInfo.keys())
    for pkg_name in sorted(pkgInfo.keys()):
        check_meta_git(pkg_name, pkgInfo[pkg_name], skip_bootstrap=True)


def deal_with_meta_git(pkg_name: str, pkg_info: PkgInfo, bootstrap: bool) -> bool:
    result = meta_pattern.match(pkg_name)

    if not result:
        return

    if "." in result.group(1):
        project, group = result.group(1).split(".")
    else:
        project = result.group(1)
        group = None

    platform = result.group(2)

    if group:
        if bootstrap:
            branch = f"{group}.{platform}-{series}-ubuntu"
        else:
            branch = f"{group}.{platform}-{series}-oem"
    else:
        if bootstrap:
            branch = f"{platform}-{series}-ubuntu"
        else:
            branch = f"{platform}-{series}-oem"

    git_command = (
        "git",
        "clone",
        "--depth",
        "1",
        "-b",
        branch,
        f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta",
        pkg_name,
    )

    with TemporaryDirectory() as tmpdir:
        messages = list()
        os.chdir(tmpdir)
        _run_command(git_command)
        git_version, _, _ = _run_command(
            [
                "dpkg-parsechangelog",
                "--show-field",
                "Version",
                "-l",
                f"{pkg_name}/debian/changelog",
            ]
        )
        if git_version != pkg_info.oem.ppa.version:
            critical(
                f"{pkg_name}'s version is {pkg_info.oem.ppa.version} in {pkg_info.oem.ppa.archive} but the version in Git repository is {git_version}."
            )
            exit(1)
        git_dir = os.path.join(tmpdir, pkg_name)

        # Deal with different changes
        if deal_with_description(
            git_dir,
            old=pkg_info.old_desc,
            new=pkg_info.new_desc,
            product_names=pkg_info.product_names,
            project=project,
        ):
            messages.append("market name")
        if deal_with_kernel_flavour(pkg_name, branch, git_dir):
            messages.append("kernel flavour")
        if not bootstrap:
            if deal_with_kernel_depends(pkg_name, branch, git_dir):
                messages.append("kernel dependency")
            if deal_with_grub_flavour(pkg_name, branch, git_dir):
                messages.append("grub flavour")
            if deal_with_maintainer_scripts(pkg_name, branch, git_dir):
                messages.append("maintainer scripts")
        if project != "sutton" and deal_with_debian_modaliases(git_dir):
            messages.append("debian/modaliases")
        if deal_with_gbp_conf(git_dir, branch):
            messages.append("debian/gbp.conf")
        if deal_with_debian_tests(pkg_name, git_dir, branch, bootstrap):
            messages.append("debian/tests")
        if bootstrap:
            meta_type = "bootstrap"
        else:
            meta_type = "real"
        if not messages:
            info(f"The {meta_type} meta of {pkg_name}'s {branch} branch looks good.")
            return False

        # Prepare the changelog and commit the changes.
        commit_message = (
            "Update the "
            + " and".join(", ".join(messages).rsplit(",", 1))
            + f" for {args.kernel}."
        )
        _run_command(["dch", "--increment", commit_message])
        _run_command(["git", "add", "debian/changelog"])
        _run_command(
            [
                "git",
                "commit",
                "-a",
                "-m",
                f"{commit_message}\n\nUpdated by oem-scripts {oem_scripts.__version__}.",
            ]
        )

        out, _, _ = _run_command(["git", "show", "--color=always"])
        if out != b"":
            debug(f"({pkg_name}:{branch}) $ git show")
            debug(out)

        # Don't use UNRELEASED in the real meta.
        if not bootstrap:
            _run_command(["sed", "-i", f"s/UNRELEASED/{series}/", "debian/changelog"])
            _run_command(["git", "commit", "-a", "--amend", "--no-edit"])

        # Tag and find it out.
        out, _, _ = _run_command(["gbp", "tag"])
        if out != b"":
            info(out)
        out, _, _ = _run_command(["git", "describe"])
        if out != b"":
            tag = out.strip()
        info(tag)

        # Build Debian binary packages
        _run_command(["gbp", "buildpackage", "-us", "-uc"])
        _run_command(["git", "reset", "--hard", "HEAD"])
        _run_command(["git", "clean", "-x", "-d", "-f"])

        # Build Debian source packages
        _run_command(["gbp", "buildpackage", "-S", "-us", "-uc"])
        _run_command(["git", "reset", "--hard", "HEAD"])
        _run_command(["git", "clean", "-x", "-d", "-f"])

        # Show the commit
        out, _, _ = _run_command(["git", "show", "--color=always"])
        if out != b"":
            warning(f"({pkg_name}:{branch}) $ git show")
            print(out)
            version, _, _ = _run_command(
                [
                    "dpkg-parsechangelog",
                    "--show-field",
                    "Version",
                    "-l",
                    "debian/changelog",
                ]
            )
            if not args.dry_run and yes_or_ask(
                args.yes,
                f"Would you like to commit and push the changes of {version} into {pkg_name}'s git {branch} branch?",
            ):
                os.chdir(git_dir)
                _run_command(
                    [
                        "git",
                        "remote",
                        "add",
                        "oem-solutions-engineers",
                        f"git+ssh://{lp.me.name}@git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta",
                    ]
                )
                _run_command(["git", "push", "oem-solutions-engineers"])
                _run_command(["git", "push", "oem-solutions-engineers", tag])


def check_meta_git(pkg_name: str, pkg_info: PkgInfo, skip_bootstrap: False) -> None:
    if args.dry_run:
        info(f"Checking {pkg_name} {pkg_info}...")
    else:
        info(f"Updating {pkg_name} {pkg_info}...")

    if not skip_bootstrap:
        deal_with_meta_git(pkg_name, pkg_info, bootstrap=True)

    deal_with_meta_git(pkg_name, pkg_info, bootstrap=False)


cache = apt_pkg.Cache(progress=None)

if args.subcommand == "list":
    for name in get_oem_meta_packages(cache):
        print(name)
elif args.subcommand == "subscribe":
    if args.meta:
        sources_in_set = [args.meta]
    else:
        ds = lp.distributions["ubuntu"].getSeries(name_or_version=series)
        packageset = lp.packagesets.getByName(
            distroseries=ds, name="canonical-oem-metapackages"
        )
        sources_in_set = sorted(set(packageset.getSourcesIncluded()))
    valid_member = False
    try:
        for member in lp.people[SUBSCRIBER].members:
            if lp.me == member:
                valid_member = True
                break
        else:
            warning(
                f"{lp.me.name} does not have the permission to subscribe '{SUBSCRIBER}'."
            )
    # Note: lp.credentials.access_token will be an instance of launchpadlib.credentials.AnonymousAccessToken.
    except lazr.restfulclient.errors.Unauthorized:
        warning(f"Anonymous does not have the permission to subscribe '{SUBSCRIBER}'.")
    ret = 0
    for name in sources_in_set:
        info(f"Checking the subscriptions for {name}...")
        source = lp.distributions["ubuntu"].getSourcePackage(name=name)
        if SUBSCRIBER in map(lambda x: x.subscriber.name, source.getSubscriptions()):
            info(f"ubuntu/{name} has subscribed '{SUBSCRIBER}'.")
            continue
        if (
            valid_member
            and not args.dry_run
            and yes_or_ask(
                args.yes,
                f"Would you like to subscribe '{SUBSCRIBER}' for ubuntu/{name}?",
            )
        ):
            # When a person is subscribed to a source package, one actually subscribe all bugs for it.
            source.addBugSubscription(subscriber=lp.people[SUBSCRIBER])
        else:
            error(f"ubuntu/{name} didn't subscribe '{SUBSCRIBER}' yet.")
            ret = 1
    exit(ret)
elif args.subcommand == "unsubscribe":
    source = lp.distributions["ubuntu"].getSourcePackage(name=args.pkgName)
    subscriptions = source.getSubscriptions()
    for subscription in subscriptions:
        if subscription.subscriber.name == SUBSCRIBER:
            info(f"ubuntu/{args.pkgName} has subscribed '{SUBSCRIBER}'.")
            if yes_or_ask(
                args.yes,
                f"Would you like to unsubscribe '{SUBSCRIBER}' for ubuntu/{args.pkgName}?",
            ):
                try:
                    source.removeBugSubscription(subscriber=lp.people[SUBSCRIBER])
                except lazr.restfulclient.errors.Unauthorized as e:
                    error(
                        f"{lp.me.name} does not have permission to unsubscribe '{SUBSCRIBER}'."
                    )
                    if args.verbose:
                        print(e)
                    exit(1)
            exit(0)
elif args.subcommand == "update":
    oem_scripts_config_ini = os.path.join(
        os.environ["HOME"], ".config/oem-scripts/config.ini"
    )
    oem_scripts_config = ConfigParser()
    oem_scripts_config.read(oem_scripts_config_ini)
    config = oem_scripts_config["private"]
    r = requests.get(
        config["archive"] + "/dists/", auth=(config["username"], config["password"])
    )
    if os.path.exists(args.meta):
        with open(args.meta) as data:
            meta_json = json.load(data)
        if "series" in meta_json and meta_json["series"] != series:
            if args.series:
                warning(
                    f'`--series {series}` is overidden as `--series {meta_json["series"]}` by the meta json file.'
                )
            series = meta_json["series"]
            animal = get_animal(series)
        pkgInfo = collect_pkg_info(
            meta_json, check_private=True, index=r.text, config=config
        )
    else:
        pkgInfo = collect_pkg_info(
            args.meta, check_private=True, index=r.text, config=config
        )
    process_update_task(pkgInfo)
elif args.subcommand == "collect":
    oem_scripts_config_ini = os.path.join(
        os.environ["HOME"], ".config/oem-scripts/config.ini"
    )
    oem_scripts_config = ConfigParser()
    oem_scripts_config.read(oem_scripts_config_ini)
    config = oem_scripts_config["private"]
    r = requests.get(
        config["archive"] + "/dists/", auth=(config["username"], config["password"])
    )
    if os.path.exists(args.meta):
        with open(args.meta) as data:
            meta_json = json.load(data)
        if "series" in meta_json and meta_json["series"] != series:
            if args.series:
                warning(
                    f'`--series {series}` is overidden as `--series {meta_json["series"]}` by the meta json file.'
                )
            series = meta_json["series"]
            animal = get_animal(series)
        pkgInfo = collect_pkg_info(
            meta_json, check_private=True, index=r.text, config=config
        )
    else:
        pkgInfo = collect_pkg_info(
            args.meta, check_private=True, index=r.text, config=config
        )
    if args.output:
        args.output.write(
            json.dumps(pkgInfo, indent=4, sort_keys=True, cls=CustomEncoder) + "\n"
        )
        args.output.write("\n")
    else:
        with open(f"{BASEDIR}/{args.meta}.json", "w+") as f:
            f.write(
                json.dumps(pkgInfo, indent=4, sort_keys=True, cls=CustomEncoder) + "\n"
            )
elif args.subcommand == "staging-copy":
    oem_scripts_config_ini = os.path.join(
        os.environ["HOME"], ".config/oem-scripts/config.ini"
    )
    oem_scripts_config = ConfigParser()
    oem_scripts_config.read(oem_scripts_config_ini)
    config = oem_scripts_config["private"]

    r = requests.get(
        config["archive"] + "/dists/", auth=(config["username"], config["password"])
    )
    pkgInfo = collect_pkg_info(
        args.meta, check_private=True, index=r.text, config=config
    )

    jobs = dict()
    dest = set()
    staging_locked = set()
    for pkg_name in sorted(pkgInfo.keys()):
        pkg_info = pkgInfo[pkg_name]
        debug(
            f"{pkg_name} ppa: {pkg_info.oem.ppa.version}, devel: {pkg_info.oem.devel.version}, staging: {pkg_info.oem.staging.version}."
        )
        if pkg_info.oem.ppa.version != pkg_info.oem.devel.version:
            warning(
                f"{pkg_name} versions are not synced between {pkg_info.oem.ppa.archive} and {pkg_info.oem.devel.archive}."
            )
        elif pkg_info.oem.staging.version == pkg_info.oem.devel.version:
            info(
                f"{pkg_name} {pkg_info.oem.devel.version} (devel) == {pkg_info.oem.staging.version} (staging) so it doesn't need to copy."
            )
        elif (
            apt_pkg.version_compare(
                pkg_info.oem.staging.version, pkg_info.oem.devel.version
            )
            > 0
        ):
            critical("This should never happen.")
            exit(1)
        else:
            dest.add(pkg_info.oem.staging.archive)
            identity = f"{pkg_info.oem.devel.archive}:{pkg_info.oem.staging.archive}"
            if identity not in jobs:
                jobs[identity] = list()
            jobs[identity].append(pkg_name)
    debug(json.dumps(jobs, indent=4, sort_keys=True))
    cloudberry = lp.projects["cloudberry"]
    assignee = lp.people["oem-archive"]
    tasks = cloudberry.searchTasks(
        status=["New", "Triaged", "Confirmed", "In Progress", "Fix Committed"],
        search_text="request of",
    )
    for task in tasks:
        bug = task.bug
        for staging in sorted(dest):
            if (
                staging in bug.description
                and "staging-lock" in bug.tags
                and "cqa-verified-staging" not in bug.tags
            ):
                debug(bug.description)
                tags = ",".join(bug.tags)
                for line in bug.description.split("\n"):
                    if line.startswith("Package: "):
                        package = line
                warning(
                    f"https://bugs.launchpad.net/bugs/{bug.id}\n\t({staging})\n\t[{tags}]\n\t{bug.title}\n\t{package}"
                )
                staging_locked.add(staging)
    for job in jobs:
        _, source, _, dest = job.split(":")
        if dest and dest in staging_locked and not args.ignore_staging_lock:
            warning(
                f"The following OEM metapackages will be skipped due to the staging-lock of {dest}.\n"
                + "\n".join(jobs[job])
            )
        else:
            title = f"request of copy_package [{source}]"
            tags = [
                "archive-request",
                "via-request-script",
                f"oem-scripts-{oem_scripts.__version__}",
                "oem-metapackages",
            ]
            if args.tag:
                tags.append(args.tag)
            if args.dry_run:
                info(f"TITLE: {title}")
                info("TAGS: " + ",".join(tags))
            else:
                debug(f"TITLE: {title}")
                debug("TAGS: " + ",".join(tags))
            packages = list()
            for pkg_name in jobs[job]:
                pkg_info = pkgInfo[pkg_name]
                packages.append(f"{pkg_name} (=={pkg_info.oem.devel.version})")
            packages = ", ".join(packages)
            distribution = series
            if dest.startswith("somerville"):
                component = remove_suffix(dest, f"-{distribution}-staging").replace(
                    f"-{animal}", ""
                )
            else:
                debug(dest)
                project, group, _ = dest.split("-", 2)
                component = f"{project}.{group}"
            production = distribution + "-" + component
            description = staging_copy_template.substitute(
                source=source,
                destination=dest,
                packages=packages,
                production=production,
                username=config["username"],
                url=config["url"],
                distribution=distribution,
                component=component,
            )
            print(description)
            if not args.dry_run and yes_or_ask(
                args.yes,
                f"Would you like to create a cloudberry bug to copy the {packages} from {source} to {dest}?",
            ):
                bug = lp.bugs.createBug(
                    description=description, target=cloudberry, title=title, tags=tags
                )
                for task in bug.bug_tasks:
                    task.importance = "High"
                    task.assignee = assignee
                    task.lp_save()
                bug.lp_save()
                print(
                    f"The cloudberry staging copy bug has been created on {bug.web_link}.\n"
                )
else:
    parser.print_help()
