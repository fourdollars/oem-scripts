#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2020  Canonical Ltd.
# Author: Shih-Yuan Lee (FourDollars) <sylee@canonical.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import argparse
import collections
import dataclasses
import difflib
import json
import lazr
import oem_scripts
import os
import re
import subprocess
import types

from apt import apt_pkg
from dataclasses import dataclass
from logging import debug, info, warning, error, critical
from oem_scripts.LaunchpadLogin import LaunchpadLogin
from oem_scripts.logging import setup_logging
from tempfile import TemporaryDirectory


class DataJSONEncoder(json.JSONEncoder):
    def default(self, o):
        if dataclasses.is_dataclass(o):
            return dataclasses.asdict(o)
        return super().default(o)


@dataclass
class PkgInfo:
    archive: str
    version: str
    old_desc: str
    new_desc: str


pattern = re.compile(r'oem-([^-]*)-(.*)-meta')
parser = argparse.ArgumentParser()

parser.add_argument("-d", "--debug",
                    help="print debug messages", action="store_true")
parser.add_argument("-q", "--quiet",
                    help="Don't print info messages", action="store_true")
parser.add_argument("-v", "--verbose", action="store_true",
                    help="print verbose messages")
parser.add_argument("--apt-dir",
                    type=str,
                    help="specify the dir for apt")

subparsers = parser.add_subparsers(dest="subcommand")

list_pkg = subparsers.add_parser('list', help='[-h]',
                                 formatter_class=argparse.RawDescriptionHelpFormatter,
                                 epilog="List all OEM meta packages in Ubuntu archive.")

subscribe = subparsers.add_parser('subscribe', help='[-h] [--yes]',
                                  formatter_class=argparse.RawDescriptionHelpFormatter,
                                  epilog="""
Make all bugs of all oem meta packages be subscribed by oem-solutions-engineers.
 (search current apt source for package lists)

Check "To all bugs in oem-qemu-meta in Ubuntu:" on https://launchpad.net/ubuntu/+source/oem-qemu-meta/+subscribe for example.
Make all bugs of all oem meta packages be subscribed by oem-solutions-engineers.
 (search current apt source for package lists)

Check "To all bugs in oem-qemu-meta in Ubuntu:" on https://launchpad.net/ubuntu/+source/oem-qemu-meta/+subscribe for example.
""")
subscribe.add_argument("--yes",
                       help="Say yes for all prompts.", action="store_true")

unsubscribe = subparsers.add_parser('unsubscribe', help='[-h] [--yes] pkgName',
                                    formatter_class=argparse.RawDescriptionHelpFormatter,
                                    epilog="""
Unsubscribe oem-solutions-engineers from oem-qemu-meta

For example,
    oem-meta-packages unsubscribe oem-qemu-meta
""")
unsubscribe.add_argument("pkgName", type=str,
                         help="Specify the package name to unsubscribe.")
unsubscribe.add_argument("--yes",
                         help="Say yes for all prompts.", action="store_true")

update = subparsers.add_parser('update', help='[-h] [--yes] [--check] [--since oem-bala-meta] [--skip "somerville,stella,sutton"] [--autopkgtest] json',
                               formatter_class=argparse.RawDescriptionHelpFormatter,
                               epilog="""
For example,
    oem-meta-packages update --check platforms.json

[
  {
    "Customer": "Dell",
    "Platform": "Bullseye V3 14 ICL-U(SMB0)",
    "Market Name": "Vostro 3401",
    "Platform LP tag": "fossa-beric-icl"
  },
  {
    "Customer": "HP",
    "Platform": "Hagrid 6U",
    "Market Name": "HP 245 G7 Notebook PC",
    "Platform LP tag": "stella-hagrid6u-id"
  },
  {
    "Customer": "Lenovo",
    "Platform": "Simon",
    "Market Name": "X1 Extreme 3",
    "Platform LP tag": "Adken"
  },
  ...
]

Update the market name and the kernel flavour of the OEM meta package to the default kernel flavour, i.e. linux-generic-hwe-20.04.""")
update.add_argument("--yes",
                    help="Say yes for all prompts.", action="store_true")
update.add_argument("--check",
                    help="Just check and don't ask any question.", action="store_true")
update.add_argument("--autopkgtest",
                    help="Run autopkgtest when checking the git repository.", action="store_true")
update.add_argument("--since",
                    help="Begin from the specified meta package. Skip previous meta packages.", type=str)
update.add_argument("--skip",
                    help="Skip checking some projects.", type=str, default="")
update.add_argument("json",
                    help="Specify the json file to read the platforms information.",
                    type=argparse.FileType('r', encoding='UTF-8'))

args = parser.parse_args()

setup_logging(debug=args.debug, quiet=args.quiet)

if args.subcommand:
    login = LaunchpadLogin()
    lp = login.lp

if args.apt_dir:
    apt_pkg.init_config()
    if args.debug:
        old = apt_pkg.config.dump()
    apt_pkg.config.set("Dir", args.apt_dir)
    apt_pkg.config.set("Dir::State::status", os.path.join(args.apt_dir, "var/lib/dpkg/status"))
    if args.debug:
        new = apt_pkg.config.dump()
        d = difflib.Differ()
        diff = d.compare(old.split('\n'), new.split('\n'))
        for line in diff:
            debug(line.strip())
    apt_pkg.init_system()


def yes_or_ask(yes: bool, message: str) -> bool:
    if yes:
        print(f"> \033[1;34m{message}\033[1;0m (y/n) y")
        return True
    while True:
        res = input(f"> \033[1;34m{message}\033[1;0m (y/n) ").lower()
        if res not in {"y", "n"}:
            continue
        if res == 'y':
            return True
        else:
            return False


def _debug_obj(pkg) -> None:

    if not args.debug:
        return

    debug(dir(pkg))

    for attr in dir(pkg):
        if not attr.startswith('__'):
            if not isinstance(pkg.__getattribute__(attr), types.BuiltinFunctionType):
                debug(f"{attr}: {pkg.__getattribute__(attr)}")


def _run_command(command: list or tuple, returncode=(0,), env=None) -> (str, str, int):
    debug("$ " + " ".join(command))
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
    out, err = proc.communicate()

    if out:
        out = out.decode('utf-8').strip()
    if err:
        err = err.decode('utf-8').strip()

    if proc.returncode not in returncode:
        critical(f"return {proc.returncode}")
        if out:
            info(out)
        if err:
            critical(err)
        exit(1)

    if out:
        debug(out)
    if err:
        debug(err)

    return (out, err, proc.returncode)


def get_oem_meta_packages(cache) -> list:
    pkg_list = []
    for pkg in cache.packages:
        name = pkg.name
        if not name.startswith('oem-') or not name.endswith('-meta'):
            continue
        pkg_list.append(name)
    return pkg_list


def _grouping_market_names(market_names: list, maxsplit=1) -> str:
    # Remove empty item
    while '' in market_names:
        market_names.remove('')
    tmp = collections.defaultdict(list)
    space_in_model = False
    try:
        for market_name in sorted(market_names):
            if maxsplit == 1:
                name, model = market_name.split(maxsplit=maxsplit)
                tmp[name].append(model)
                if ' ' in model:
                    space_in_model = True
            elif maxsplit == 2:
                brand, name, model = market_name.split(maxsplit=maxsplit)
                tmp[brand + ' ' + name].append(model)
                if ' ' in model:
                    space_in_model = True
    except ValueError:
        return ', '.join(sorted(market_names))

    if space_in_model:
        return ', '.join(f"{name} {', '.join(models)}" for name, models in tmp.items())
    else:
        return ', '.join(f"{name} {'/'.join(models)}" for name, models in tmp.items())


def deal_with_description(git_dir, old, new) -> bool:
    if not old or not new:
        return False
    os.chdir(git_dir)
    file_path = os.path.join(git_dir, 'debian', 'control')
    with open(file_path, 'r') as control:
        lines = control.readlines()
    for i, line in enumerate(lines):
        if old in line:
            lines[i] = line.replace(old, new)
    info(f'"{old}" will be replaced by "{new}".')
    with open(file_path, 'w') as control:
        control.writelines(lines)
    _run_command(["git", "add", "debian/control"])
    return True


def deal_with_kernel_flavour(pkg_name, branch, git_dir) -> bool:
    os.chdir(git_dir)
    idx = -1
    kernel_flavour = None
    file_path = os.path.join(git_dir, 'debian', 'control')
    with open(file_path, 'r') as control:
        lines = control.readlines()
    for i, line in enumerate(lines):
        if line.startswith('XB-Ubuntu-OEM-Kernel-Flavour:'):
            kernel_flavour = line[len('XB-Ubuntu-OEM-Kernel-Flavour:'):].strip()
            idx = i
            break

    if not kernel_flavour:
        critical(f"There is no XB-Ubuntu-OEM-Kernel-Flavour in debian/control of {branch} for {pkg_name}.")
        exit(1)

    debug(f"XB-Ubuntu-OEM-Kernel-Flavour: {kernel_flavour}")

    if kernel_flavour == 'default':
        return False

    lines[idx] = "XB-Ubuntu-OEM-Kernel-Flavour: default\n"
    with open(file_path, 'w') as control:
        control.writelines(lines)
    _run_command(["git", "add", "debian/control"])
    return True


def deal_with_kernel_depends(pkg_name, branch, git_dir) -> bool:
    os.chdir(git_dir)
    idx = -1
    file_path = os.path.join(git_dir, 'debian', 'control')
    with open(file_path, 'r') as control:
        lines = control.readlines()
    for i, line in enumerate(lines):
        if line.startswith('Depends:'):
            idx = i
            break
    debug(lines[idx].strip())

    if idx == -1 or 'linux-oem-20.04' not in lines[idx]:
        return False

    lines[idx] = lines[idx].replace('linux-oem-20.04', 'linux-generic-hwe-20.04')
    with open(file_path, 'w') as control:
        control.writelines(lines)
    _run_command(["git", "add", "debian/control"])
    return True


def deal_with_debian_tests(pkg_name: str, git_dir: str, branch: str, bootstrap: bool) -> bool:
    os.chdir(git_dir)

    changed = False

    tests_folder = os.path.join(git_dir, 'debian', 'tests')
    if not os.path.exists(tests_folder):
        os.mkdir(tests_folder)

    control_content = """Tests: meta
Depends: @
Restrictions: needs-root
"""
    control = os.path.join(git_dir, 'debian', 'tests', 'control')

    if os.path.exists(control):
        with open(control, 'r') as f:
            if f.read() != control_content:
                with open(control, 'w') as fp:
                    fp.write(control_content)
                _run_command(["git", "add", "debian/tests/control"])
                changed = True
    else:
        with open(control, 'w') as fp:
            fp.write(control_content)
        _run_command(["git", "add", "debian/tests/control"])
        changed = True

    meta_content = """#!/bin/bash

exec 2>&1
set -euo pipefail
IFS=$'\\n\\t'

apt-get update
apt-get full-upgrade --yes

apt-get update
apt-get full-upgrade --yes
"""
    if not bootstrap:
        meta_content += "\ngrep ^GRUB_FLAVOUR_ORDER= /etc/default/grub.d/oem-flavour.cfg\n"
    meta_content += f"\napt-get autoremove --purge --yes {pkg_name}\n"
    meta = os.path.join(git_dir, 'debian', 'tests', 'meta')
    old_meta = os.path.join(git_dir, 'debian', 'tests', pkg_name)

    if os.path.exists(old_meta):
        _run_command(["git", "rm", "-f", f"debian/tests/{pkg_name}"])
        changed = True

    if os.path.exists(meta):
        with open(meta, 'r') as f:
            if f.read() != meta_content:
                with open(meta, 'w') as fp:
                    fp.write(meta_content)
                _run_command(["git", "add", "debian/tests/meta"])
                changed = True
    else:
        with open(meta, 'w') as fp:
            fp.write(meta_content)
        _run_command(["git", "add", "debian/tests/meta"])
        changed = True

    return changed


def deal_with_gbp_conf(git_dir, branch) -> bool:
    os.chdir(git_dir)
    file_path = os.path.join(git_dir, 'debian', 'gbp.conf')
    gbp_conf = f"""[DEFAULT]
pristine-tar = False
debian-branch = {branch}
debian-tag = {branch}_%(version)s
"""
    if os.path.exists(file_path):
        with open(file_path, 'r') as f:
            if f.read() == gbp_conf:
                return False
    with open(file_path, 'w') as f:
        f.write(gbp_conf)
    _run_command(["git", "add", "debian/gbp.conf"])
    return True


def deal_with_grub_flavour(pkg_name, branch, git_dir) -> bool:
    os.chdir(git_dir)
    grub_flavour = None
    file_path = os.path.join(git_dir, 'oem-flavour.cfg')
    postinst_path = os.path.join(git_dir, 'debian', 'postinst')
    postrm_path = os.path.join(git_dir, 'debian', 'postrm')
    pkg_postinst_path = os.path.join(git_dir, 'debian', f'{pkg_name}.postinst')
    pkg_postrm_path = os.path.join(git_dir, 'debian', f'{pkg_name}.postrm')
    if os.path.exists(file_path):
        with open(file_path, 'r') as oem_flavour:
            for line in oem_flavour:
                if line.startswith('GRUB_FLAVOUR_ORDER='):
                    grub_flavour = line[len('GRUB_FLAVOUR_ORDER='):].strip()
                    break
    if grub_flavour == 'generic':
        return False

    if not grub_flavour:
        with open(os.path.join(git_dir, 'debian', 'install'), 'a') as f:
            f.write(f"oem-flavour.cfg /usr/share/{pkg_name}/\n")
        _run_command(["git", "add", "debian/install"])

        if os.path.exists(postinst_path) or os.path.exists(pkg_postinst_path):
            critical(f"debian/postinst or debian/{pkg_name}.postinst already exists. You need to manually deal with the oem-flavour.cfg.")
            exit(1)
        else:
            with open(postinst_path, 'w') as f:
                f.write(f'''#!/bin/sh

set -e

. /usr/share/debconf/confmodule

case "$1" in
    configure)
        mkdir -p /etc/default/grub.d/
        ln -s /usr/share/{pkg_name}/oem-flavour.cfg /etc/default/grub.d/oem-flavour.cfg
        update-grub || true
    ;;
esac

#DEBHELPER#
''')
        _run_command(["git", "add", "debian/postinst"])

        if os.path.exists(postrm_path) or os.path.exists(pkg_postrm_path):
            critical(f"debian/postrm or debian/{pkg_name}.postrm already exists. You need to manually deal with the oem-flavour.cfg.")
            exit(1)
        else:
            with open(postrm_path, 'w') as f:
                f.write('''#!/bin/sh

set -e

. /usr/share/debconf/confmodule

case "$1" in
    remove|purge)
        rm -f /etc/default/grub.d/oem-flavour.cfg
        update-grub || true
    ;;
esac

#DEBHELPER#
''')
        _run_command(["git", "add", "debian/postrm"])

    with open(file_path, 'w') as f:
        f.write(f"""# This file is automatically generated by {pkg_name}, and changes will be overriden
GRUB_FLAVOUR_ORDER=generic
""")
    _run_command(["git", "add", "oem-flavour.cfg"])

    return True


# Python 3.9 supports this.
def remove_prefix(s, prefix):
    return s[len(prefix):] if s.startswith(prefix) else s


# Python 3.9 supports this.
def remove_suffix(s, suffix):
    return s[:-len(suffix)] if s.endswith(suffix) else s


def remove_prefix_suffix(s, prefix, suffix):
    return remove_suffix(remove_prefix(s, prefix), suffix)


def search_ppa_and_version(project: str, group: str, platform: str, pkg_name: str, archive_name=None, oem_archive=lp.people['oem-archive']):
    if archive_name:
        archive = oem_archive.getPPAByName(name=archive_name)
    elif project == 'somerville':
        archive = oem_archive.getPPAByName(name=f"{project}-fossa-{platform}")
    elif project == 'stella':
        archive = oem_archive.getPPAByName(name=f"{project}-{group}-ouagadougou")
    elif project == 'sutton':
        try:
            archive = oem_archive.getPPAByName(name=f"{project}-{group}-ouagadougou")
        except lazr.restfulclient.errors.NotFound:
            archive = oem_archive.getPPAByName(name=f"{project}-{group}")
    sources = archive.getPublishedSources()
    version = ""
    for source in sources:
        if source.source_package_name == pkg_name and \
                apt_pkg.version_compare(source.source_package_version, version) > 0:
            version = source.source_package_version
    if version:
        return archive.name, version
    else:
        return None, None


def process_update_task(check_only: bool, data) -> None:
    somerville = dict()
    stella = dict()
    sutton = dict()

    for item in json.load(data):
        customer = item['Customer'].lower()
        platform = item['Platform'].lower()
        codename = item['Codename'].lower()
        group = item['Group'].lower()
        market_name = item['Market Name']
        lp_tag = item['Platform LP tag'].lower()
        if 'dell' in customer:
            if 'somerville' in args.skip:
                continue
            platform = remove_prefix(lp_tag, 'fossa-')
            lst = somerville.get(platform, [])
            lst.append(market_name)
            somerville[platform] = lst
        elif 'hp' in customer:
            if 'stella' in args.skip:
                continue
            lst = stella.get(f"{group}-{codename}", [])
            lst.append(market_name)
            stella[f"{group}-{codename}"] = lst
        elif 'lenovo' in customer:
            if 'sutton' in args.skip:
                continue
            lst = sutton.get(f"{group}-{codename}", [])
            lst.append(market_name)
            sutton[f"{group}-{codename}"] = lst

    debug(somerville)
    debug(stella)
    debug(sutton)

    pkgNamesInArchive = get_oem_meta_packages(cache)

    pkgInfo = dict()

    info("Finding the corresponding PPAs...")
    for k, v in somerville.items():
        pkg_name = 'oem-somerville-' + k + '-meta'
        archive, version = search_ppa_and_version("somerville", None, k, pkg_name)
        if archive is None:
            archive, version = search_ppa_and_version("somerville", None, k, pkg_name, "somerville")
        if archive is None:
            critical(f"It can not find any private PPA that contains {pkg_name}.")
            exit(1)

        debug(f"{pkg_name} {version} exists in ppa:~oem-archive/{archive}")
        pkgInfo[pkg_name] = PkgInfo(archive=archive, version=version, old_desc="", new_desc="")

        if pkg_name in pkgNamesInArchive and ''.join(v):
            new_desc = _grouping_market_names(v)
            if "Dell" not in new_desc:
                new_desc = "Dell " + new_desc
            pkgInfo[pkg_name].old_desc = f"Somerville {k.title()} platform"
            pkgInfo[pkg_name].new_desc = new_desc

    for k, v in stella.items():
        pkg_name = 'oem-stella.' + k + '-meta'
        group, codename = k.split('-', 1)

        archive, version = search_ppa_and_version("stella", group, codename, pkg_name)
        if archive is None:
            critical(f"It can not find any private PPA that contains {pkg_name}.")
            exit(1)

        debug(f"{pkg_name} {version} exists in ppa:~oem-archive/{archive}")
        pkgInfo[pkg_name] = PkgInfo(archive=archive, version=version, old_desc="", new_desc="")

        if pkg_name in pkgNamesInArchive and ''.join(v):
            new_desc = _grouping_market_names(v, maxsplit=2)
            if "HP" not in new_desc:
                new_desc = "HP " + new_desc
            pkgInfo[pkg_name].old_desc = f"Stella {group.title()} {codename.title()} platform"
            pkgInfo[pkg_name].new_desc = new_desc

    for k, v in sutton.items():
        pkg_name = 'oem-sutton.' + k + '-meta'
        group, codename = k.split('-', 1)

        archive, version = search_ppa_and_version("sutton", group, codename, pkg_name)
        if archive is None:
            critical(f"It can not find any private PPA that contains {pkg_name}.")
            exit(1)

        debug(f"{pkg_name} {version} exists in ppa:~oem-archive/{archive}")
        pkgInfo[pkg_name] = PkgInfo(archive=archive, version=version, old_desc="", new_desc="")

        if pkg_name in pkgNamesInArchive and ''.join(v):
            new_desc = _grouping_market_names(v)
            if "Lenovo" not in new_desc:
                new_desc = "Lenovo " + new_desc
            pkgInfo[pkg_name].old_desc = f"Sutton {group.title()} {codename.title()} platform"
            pkgInfo[pkg_name].new_desc = new_desc

    debug(json.dumps(pkgInfo, indent=4, sort_keys=True, cls=DataJSONEncoder))

    for pkg_name in sorted(pkgInfo.keys()):
        if args.since:
            if pkg_name != args.since:
                info(f"Skip {pkg_name}")
                continue
            else:
                args.since = None
        check_meta_git(pkg_name, pkgInfo[pkg_name], check_only, skip_bootstrap=True)


def deal_with_meta_git(pkg_name: str, pkg_info: PkgInfo, bootstrap: bool, check_only: bool) -> bool:
    result = pattern.match(pkg_name)

    if not result:
        return

    if '.' in result.group(1):
        project, group = result.group(1).split('.')
    else:
        project = result.group(1)
        group = None

    platform = result.group(2)

    if group:
        if bootstrap:
            branch = f"{group}.{platform}-focal-ubuntu"
        else:
            branch = f"{group}.{platform}-focal-oem"
    else:
        if bootstrap:
            branch = f"{platform}-focal-ubuntu"
        else:
            branch = f"{platform}-focal-oem"

    git_command = ("git", "clone", "--depth", "1", "-b", branch, f"https://git.launchpad.net/~oem-solutions-engineers/pc-enablement/+git/oem-{project}-projects-meta", pkg_name)

    with TemporaryDirectory() as tmpdir:
        messages = list()
        os.chdir(tmpdir)
        _run_command(git_command)
        git_dir = os.path.join(tmpdir, pkg_name)

        # Deal with different changes
        if deal_with_description(git_dir, pkg_info.old_desc, pkg_info.new_desc):
            messages.append("market name")
        if deal_with_kernel_flavour(pkg_name, branch, git_dir):
            messages.append("kernel flavour")
        if not bootstrap:
            if deal_with_kernel_depends(pkg_name, branch, git_dir):
                messages.append("kernel dependency")
            if deal_with_grub_flavour(pkg_name, branch, git_dir):
                messages.append("grub flavour")
        if deal_with_gbp_conf(git_dir, branch):
            messages.append("debian/gbp.conf")
        if deal_with_debian_tests(pkg_name, git_dir, branch, bootstrap):
            messages.append("debian/tests")
        if bootstrap:
            meta_type = "bootstrap"
        else:
            meta_type = "real"
        if not messages:
            info(f"The {meta_type} meta of {pkg_name}'s {branch} branch looks good.")
            return False

        # Prepare the changelog and commit the changes.
        commit_message = 'Update the ' + ' and'.join(', '.join(messages).rsplit(',', 1)) + '.'
        _run_command(['dch', '--increment', commit_message])
        _run_command(["git", "add", "debian/changelog"])
        _run_command(['git', 'commit', '-a', '-m', f"{commit_message}\n\nUpdated by oem-scripts {oem_scripts.__version__}."])

        out, _, _ = _run_command(['git', 'show', '--color=always'])
        if out != b'':
            debug(f"({pkg_name}:{branch}) $ git show")
            debug(out)

        # Run autopkgtest
        if args.autopkgtest:
            archives = set()
            archives.add(pkg_info.archive)

            if project == 'somerville':
                archives.add(f"{project}")
                if pkg_info.archive != project:
                    ppa_str = f"ppa:oem-archive/{project} ppa:oem-archive/{pkg_info.archive}"
                else:
                    ppa_str = f"ppa:oem-archive/{project}"
            elif project == 'stella' or project == 'sutton':
                archives.add(f"{project}-ouagadougou")
                if pkg_info.archive != f"{project}-ouagadougou":
                    ppa_str = f"ppa:oem-archive/{project}-ouagadougou ppa:oem-archive/{pkg_info.archive}"
                else:
                    ppa_str = f"ppa:oem-archive/{project}-ouagadougou"
            oem_archive = lp.people['oem-archive']
            for ppa in archives:
                source_lists = "\n".join(lp.me.getArchiveSubscriptionURLs())
                if f"oem-archive/{ppa}/ubuntu" not in source_lists:
                    archive = oem_archive.getPPAByName(name=ppa)
                    if archive is None:
                        critical(f"It can not find ppa:oem-archive/{ppa}.")
                        exit(1)
                    archive.newSubscription(subscriber=lp.me)
                    archive.lp_save()
                    info(f"Subscribed ppa:oem-archive/{ppa}")
            with open(f'{pkg_name}.list', 'r') as f:
                source_list = f.read().strip()
            with open(f'autopkgtest-{pkg_name}-auto', 'w') as f:
                f.write(f'''#!/bin/bash

set -euo pipefail
IFS=$'\n\t'

# shellcheck source=config.sh
source /usr/share/oem-scripts/config.sh 2>/dev/null || source config.sh

# Get the path of autopkgtest-oem-scripts-auto, it's same path with launchpad-api
cur_dir=$(cd "$(dirname "$0")" || exit; pwd)

if ! valid_oem_scripts_config; then
    >&2 echo "Please execute \\`launchpad-api\\` to get the token for Launchpad API first."
    exit 1
fi

autopkgtest-collect-credentials {ppa_str} "$@"

cat << END
install_pkgs ubuntu-oem-keyring
mkdir -p "\\$root"/etc/apt/sources.list.d
cat > "\\$root"/etc/apt/sources.list.d/custom.list << ENDLINE
{source_list}
ENDLINE
chroot "\\$root" apt-get update
END
''')
            os.chmod(f'autopkgtest-{pkg_name}-auto', 0o755)
            info(f"({pkg_name}:{branch}) $ run-autopkgtest lxc focal -C")
            _run_command(['run-autopkgtest', 'lxc', 'focal', '-C'])
            _run_command(['git', 'reset', '--hard', 'HEAD'])
            _run_command(['git', 'clean', '-x', '-d', '-f'])

        # Don't use UNRELEASED in the real meta.
        if not bootstrap:
            _run_command(['sed', '-i', 's/UNRELEASED/focal/', 'debian/changelog'])
            _run_command(['git', 'commit', '-a', '--amend', '--no-edit'])

        # Tag and find it out.
        out, _, _ = _run_command(['gbp', 'tag'])
        if out != b'':
            info(out)
        out, _, _ = _run_command(['git', 'describe'])
        if out != b'':
            tag = out.strip()
        info(tag)

        # Build Debian binary packages
        _run_command(['gbp', 'buildpackage', '-us', '-uc'])
        _run_command(['git', 'reset', '--hard', 'HEAD'])
        _run_command(['git', 'clean', '-x', '-d', '-f'])

        # Build Debian source packages
        _run_command(['gbp', 'buildpackage', '-S', '-us', '-uc'])
        _run_command(['git', 'reset', '--hard', 'HEAD'])
        _run_command(['git', 'clean', '-x', '-d', '-f'])

        # Show the commit
        out, _, _ = _run_command(['git', 'show', '--color=always'])
        if out != b'':
            warning(f"({pkg_name}:{branch}) $ git show")
            print(out)
            if not check_only and yes_or_ask(args.yes, f"Would you like to commit and push the changes above into {pkg_name}'s {branch} branch?"):
                pass


def check_meta_git(pkg_name: str, pkg_info: PkgInfo, check_only: bool, skip_bootstrap: False) -> None:
    if check_only:
        info(f"Checking {pkg_name} {pkg_info}...")
    else:
        info(f"Updating {pkg_name} {pkg_info}...")

    if not skip_bootstrap:
        deal_with_meta_git(pkg_name, pkg_info, bootstrap=True, check_only=check_only)

    deal_with_meta_git(pkg_name, pkg_info, bootstrap=False, check_only=check_only)


cache = apt_pkg.Cache(progress=None)

if args.subcommand == 'list':
    for name in get_oem_meta_packages(cache):
        print(name)
elif args.subcommand == 'subscribe':
    for name in get_oem_meta_packages(cache):
        info(f"Checking the subscriptions for {name}...")
        source = lp.distributions['ubuntu'].getSourcePackage(name=name)
        if 'oem-solutions-engineers' in map(lambda x: x.subscriber.name, source.getSubscriptions()):
            info(f"ubuntu/{name} has subscribed oem-solutions-engineers.")
            continue
        warning(f"ubuntu/{name} didn't subscribe oem-solutions-engineers yet.")
        if yes_or_ask(args.yes, f"Would you like to subscribe 'oem-solutions-engineers' for ubuntu/{name}?"):
            try:
                # When a person is subscribed to a source package, one actually subscribe all bugs for it.
                source.addBugSubscription(subscriber=lp.people['oem-solutions-engineers'])
            except lazr.restfulclient.errors.Unauthorized as e:
                error(f"{lp.me.name} does not have permission to subscribe oem-solutions-engineers.")
                if args.verbose:
                    print(e)
                exit(1)
elif args.subcommand == 'unsubscribe':
    source = lp.distributions['ubuntu'].getSourcePackage(name=args.pkgName)
    subscriptions = source.getSubscriptions()
    for subscription in subscriptions:
        if subscription.subscriber.name == 'oem-solutions-engineers':
            info(f"ubuntu/{args.pkgName} has subscribed oem-solutions-engineers.")
            if yes_or_ask(args.yes, f"Would you like to unsubscribe 'oem-solutions-engineers' for ubuntu/{args.pkgName}?"):
                try:
                    source.removeBugSubscription(subscriber=lp.people['oem-solutions-engineers'])
                except lazr.restfulclient.errors.Unauthorized as e:
                    error(f"{lp.me.name} does not have permission to unsubscribe oem-solutions-engineers.")
                    if args.verbose:
                        print(e)
                    exit(1)
            exit(0)
elif args.subcommand == 'update':
    process_update_task(args.check, args.json)
else:
    parser.print_help()
